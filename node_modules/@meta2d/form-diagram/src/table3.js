var __assign = (this && this.__assign) || function () {
    __assign = Object.assign || function(t) {
        for (var s, i = 1, n = arguments.length; i < n; i++) {
            s = arguments[i];
            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
                t[p] = s[p];
        }
        return t;
    };
    return __assign.apply(this, arguments);
};
var __read = (this && this.__read) || function (o, n) {
    var m = typeof Symbol === "function" && o[Symbol.iterator];
    if (!m) return o;
    var i = m.call(o), r, ar = [], e;
    try {
        while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
    }
    catch (error) { e = { error: error }; }
    finally {
        try {
            if (r && !r.done && (m = i["return"])) m.call(i);
        }
        finally { if (e) throw e.error; }
    }
    return ar;
};
var __spreadArray = (this && this.__spreadArray) || function (to, from, pack) {
    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
        if (ar || !(i in from)) {
            if (!ar) ar = Array.prototype.slice.call(from, 0, i);
            ar[i] = from[i];
        }
    }
    return to.concat(ar || Array.prototype.slice.call(from));
};
var __values = (this && this.__values) || function(o) {
    var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
    if (m) return m.call(o);
    if (o && typeof o.length === "number") return {
        next: function () {
            if (o && i >= o.length) o = void 0;
            return { value: o && o[i++], done: !o };
        }
    };
    throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
import { ReplaceMode } from './common';
import { calcRightBottom, calcTextLines, deepClone, calcCenter } from '../../core';
var lineGap = 4;
var rowHeadersWidth = 20;
export function table3(ctx, pen) {
    if (!pen.onAdd) {
        pen.onAdd = onAdd;
        if (!pen.rowPos || !pen.colPos || !pen.calculative.maxOffsetY) {
            pen.onAdd(pen);
        }
        pen.onMouseMove = onMouseMove;
        pen.onMouseLeave = onMouseLeave;
        pen.onMouseDown = onMouseDown;
        pen.onShowInput = onShowInput;
        pen.onInput = onInput;
        pen.onValue = onValue;
        pen.onBeforeValue = beforeValue;
        pen.onMouseEnter = onMouseEnter;
        pen.onWheel = onWheel;
        pen.onDestroy = onDestroy;
        pen.onContextmenu = onContextmenu;
        pen.onResize = onResize;
        pen.onMove = onMove;
    }
    // console.time('table3');
    if (pen.data.length !== pen.rowPos.length) {
        pen.initWorldRect = null;
        pen.calculative.isUpdateData = true;
        pen.onValue(pen);
    }
    if (pen.data[0].length !== pen.colPos.length) {
        pen.initWorldRect = null;
        pen.calculative.isUpdateData = true;
        pen.onValue(pen);
    }
    var data = pen.calculative.canvas.store.data;
    var options = pen.calculative.canvas.store.options;
    pen.colHeaders =
        pen.colHeaders === undefined ? pen.hasHeader : pen.colHeaders;
    pen.color = pen.color || data.color || options.color;
    pen.textColor =
        pen.textColor || pen.color || data.textColor || options.textColor;
    pen.activeColor = pen.activeColor || options.activeColor;
    pen.hoverColor = pen.hoverColor || options.hoverColor;
    pen.activeBackground = pen.activeBackground || options.activeBackground;
    pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
    if (!pen.colHeaders) {
        ctx.save();
        ctx.beginPath();
        var _a = pen.calculative.worldRect, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
        ctx.fillStyle = '#fff0';
        ctx.rect(x - 1, y - 1, width + 2, height + 2);
        ctx.fill();
        ctx.clip();
    }
    // 画网格线
    drawGridLine(ctx, pen);
    // 画单元格
    drawCell(ctx, pen);
    //绘制框选的、待合并的cell
    drawMergeCell(ctx, pen);
    // 画title
    ctx.restore();
    // 画选中列
    drawNote(ctx, pen);
    drawActiceCol(ctx, pen);
    pen.isFirstTime = false;
    // console.timeEnd('table3');
}
function drawNote(ctx, pen) {
    if (!pen.calculative.hover) {
        return;
    }
    if (!pen.calculative.hoverCell) {
        return;
    }
    if (pen.calculative.isInput) {
        return;
    }
    if (!pen.calculative.isHover) {
        return;
    }
    var rect = pen.calculative.worldRect;
    var mousePos = pen.calculative.canvas.mousePos;
    if (!(mousePos.x > rect.x &&
        mousePos.x < rect.x + rect.width &&
        mousePos.y > rect.y &&
        mousePos.y < rect.y + rect.height)) {
        pen.calculative.hover = false;
        pen.calculative.isHover = false;
        pen.calculative.hoverCell = undefined;
        return;
    }
    var _a = pen.calculative.hoverCell, row = _a.row, col = _a.col;
    var _b = pen.calculative.canvas.mousePos, x = _b.x, y = _b.y;
    if (!pen.data[row]) {
        return;
    }
    var text = pen.data[row][col];
    if (typeof text === 'object' || !text) {
        return;
    }
    ctx.save();
    ctx.beginPath();
    ctx.textAlign = 'start';
    ctx.textBaseline = 'middle';
    ctx.font = ctx.font =
        (pen.calculative.fontStyle || '') +
            ' normal ' +
            (pen.calculative.fontWeight || '') +
            ' ' +
            (pen.calculative.fontSize || 12) +
            'px ' +
            pen.calculative.fontFamily;
    var noteWidth = ctx.measureText(text).width;
    ctx.beginPath();
    ctx.fillStyle = '#fff';
    ctx.strokeStyle = '#000';
    ctx.moveTo(x, y);
    ctx.rect(x - 10, y, noteWidth + 20, 20);
    ctx.fill();
    ctx.stroke();
    ctx.beginPath();
    ctx.fillStyle = '#000';
    ctx.fillText(text, x, y + 10);
    ctx.restore();
}
function initRect(pen) {
    var colPos = [];
    var rowPos = [];
    var colStyle = {};
    if (!pen.rowHeight) {
        pen.rowHeight = 40;
    }
    if (!pen.colWidth) {
        pen.colWidth = 150;
    }
    var width = 0;
    //获取所有col width
    var _col = pen.styles &&
        pen.styles.filter(function (item) {
            return item.col !== undefined && item.row === undefined && item.width;
        });
    var _colWidthMap = {};
    _col &&
        _col.forEach(function (_c) {
            _colWidthMap[_c.col] = _c.width;
        });
    if (pen.rowHeaders) {
        width = rowHeadersWidth;
    }
    var _loop_1 = function (i) {
        width +=
            (_colWidthMap[i] || pen.colWidth) *
                pen.calculative.canvas.store.data.scale;
        colPos.push(width);
        var style = pen.styles &&
            pen.styles.filter(function (item) {
                return item.col === i && item.row === undefined;
            });
        if (style) {
            colStyle[i] = style[0];
        }
    };
    for (var i = 0; i < pen.data[0].length; i++) {
        _loop_1(i);
    }
    var height = 0;
    //获取所有row height
    var _row = pen.styles &&
        pen.styles.filter(function (item) {
            return item.col === undefined && item.row !== undefined && item.height;
        });
    var _rowHeightMap = {};
    _row &&
        _row.forEach(function (_r) {
            _rowHeightMap[_r.row] = _r.height;
        });
    // 显示表头
    var finalHight = height;
    for (var j = 0; j < pen.data.length; j++) {
        height +=
            (_rowHeightMap[j] || pen.rowHeight) *
                pen.calculative.canvas.store.data.scale;
        rowPos.push(height);
        if (j < pen.maxNum) {
            finalHight = height;
        }
    }
    pen.calculative.maxOffsetY =
        (height - finalHight) / pen.calculative.canvas.store.data.scale;
    if (pen.initWorldRect) {
        return;
    }
    pen.colPos = colPos;
    pen.rowPos = rowPos;
    pen.colStyle = colStyle;
    pen.initScale = pen.calculative.canvas.store.data.scale;
    pen.tableWidth = width;
    pen.tableHeight = finalHight || height;
    //   if (!pen.width) {
    pen.calculative.width = width;
    pen.calculative.height = finalHight || height;
    pen.calculative.width = width;
    pen.calculative.height = finalHight || height;
    if (!pen.height) {
        pen.height = pen.calculative.height;
    }
    if (!pen.width) {
        pen.width = pen.calculative.width;
    }
    var x = pen.x;
    var y = pen.y;
    if (pen.parentId) {
        var parentPen = pen.calculative.canvas.store.pens[pen.parentId];
        x =
            parentPen.calculative.worldRect.x +
                parentPen.calculative.worldRect.width * pen.x;
        y =
            parentPen.calculative.worldRect.y +
                parentPen.calculative.worldRect.height * pen.y;
    }
    pen.calculative.worldRect = {
        x: x,
        y: y,
        height: pen.calculative.height,
        width: pen.calculative.width,
        center: {
            x: pen.x + pen.calculative.width / 2,
            y: pen.y + pen.calculative.height / 2,
        },
    };
    pen.width = pen.calculative.width;
    pen.height = pen.calculative.height;
    if (!pen.initWorldRect) {
        pen.initWorldRect = {
            width: pen.calculative.worldRect.width,
            height: pen.calculative.worldRect.height,
        };
    }
    calcRightBottom(pen.calculative.worldRect);
    //   }
}
function drawGridLine(ctx, pen) {
    var _a;
    if (!pen.colPos) {
        return;
    }
    // const worldRect = pen.calculative.worldRect;
    var _b = pen.calculative.worldRect, x = _b.x, y = _b.y, width = _b.width, height = _b.height, ex = _b.ex, ey = _b.ey;
    ctx.save();
    ctx.beginPath();
    ctx.strokeStyle = pen.color;
    // 绘画最外框
    // ctx.beginPath();
    // ctx.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
    var wr = pen.calculative.borderRadius || 0, hr = wr;
    if (wr < 1) {
        wr = width * wr;
        hr = height * hr;
    }
    var r = wr < hr ? wr : hr;
    if (width < 2 * r) {
        r = width / 2;
    }
    if (height < 2 * r) {
        r = height / 2;
    }
    ctx.moveTo(x + r, y);
    ctx.arcTo(ex, y, ex, ey, r);
    ctx.arcTo(ex, ey, x, ey, r);
    ctx.arcTo(x, ey, x, y, r);
    ctx.arcTo(x, y, ex, y, r);
    if (pen.background) {
        ctx.fillStyle = pen.background;
        ctx.fill();
    }
    if (pen.bordered !== false) {
        ctx.strokeStyle = pen.borderColor || '#424B61';
        ctx.stroke();
    }
    if (pen.hLine !== false) {
        // 绘画行的线
        var last = pen.rowPos[pen.rowPos.length - 1];
        if (pen.colHeaders) {
            //绘制表格 bottom的线
            ctx.beginPath();
            ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y +
                (pen.rowPos[0] * pen.calculative.worldRect.height) / pen.tableHeight);
            ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y +
                (pen.rowPos[0] * pen.calculative.worldRect.height) / pen.tableHeight);
            ctx.strokeStyle = pen.borderColor || '#424B61';
            ctx.stroke();
        }
        var _loop_2 = function (i) {
            var item = pen.rowPos[i];
            if (item === last) {
                return "continue";
            }
            var y_1 = (item * pen.calculative.worldRect.height) / pen.tableHeight -
                pen.offsetY * pen.calculative.canvas.store.data.scale;
            if (pen.colHeaders) {
                if (y_1 <
                    0 +
                        (pen.rowPos[0] * pen.calculative.worldRect.height) /
                            pen.tableHeight ||
                    y_1 > pen.calculative.worldRect.height) {
                    return "continue";
                }
            }
            else {
                if (y_1 < 0 || y_1 > pen.calculative.worldRect.height) {
                    return "continue";
                }
            }
            var cells = (_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.filter(function (_cells) { return _cells.row <= i && i < _cells.row + _cells.rowspan - 1; });
            ctx.beginPath();
            ctx.strokeStyle = pen.borderColor || '#424B61';
            if (cells === null || cells === void 0 ? void 0 : cells.length) {
                //合并单元格情况
                cells.sort(function (a, b) { return a.col - b.col; });
                ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y_1);
                for (var j = 0; j < cells.length; j++) {
                    var endIdx = cells[j].col - 1 + cells[j].colspan;
                    if (endIdx >= pen.colPos.length) {
                        endIdx = pen.colPos.length - 1;
                    }
                    var startX = (pen.colPos[cells[j].col - 1] * pen.calculative.worldRect.width) /
                        pen.tableWidth;
                    var endX = (pen.colPos[endIdx] * pen.calculative.worldRect.width) /
                        pen.tableWidth;
                    ctx.lineTo(pen.calculative.worldRect.x + startX, pen.calculative.worldRect.y + y_1);
                    ctx.moveTo(pen.calculative.worldRect.x + endX, pen.calculative.worldRect.y + y_1);
                }
                ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y_1);
            }
            else {
                ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y_1);
                ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y_1);
            }
            ctx.stroke();
        };
        for (var i = 0; i < pen.rowPos.length; i++) {
            _loop_2(i);
        }
    }
    if (pen.vLine !== false) {
        // 绘画列的线
        var last_1 = pen.colPos[pen.colPos.length - 1];
        pen.colPos.forEach(function (item, i) {
            var _a;
            if (item === last_1) {
                return;
            }
            var cells = (_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.filter(function (_cells) { return _cells.col <= i && i < _cells.col + _cells.colspan - 1; });
            ctx.beginPath();
            ctx.strokeStyle = pen.borderColor || '#424B61';
            if (cells === null || cells === void 0 ? void 0 : cells.length) {
                //合并单元格情况
                cells.sort(function (a, b) { return a.row - b.row; });
                var x_1 = (item * pen.calculative.worldRect.width) / pen.tableWidth;
                ctx.moveTo(pen.calculative.worldRect.x + x_1, pen.calculative.worldRect.y);
                if (pen.colHeaders) {
                    ctx.lineTo(pen.calculative.worldRect.x + x_1, pen.calculative.worldRect.y +
                        (pen.rowPos[0] * pen.calculative.worldRect.height) /
                            pen.tableHeight);
                }
                for (var j = 0; j < cells.length; j++) {
                    var endIdx = cells[j].row - 1 + cells[j].rowspan;
                    if (endIdx >= pen.rowPos.length) {
                        endIdx = pen.rowPos.length - 1;
                    }
                    var startY = (pen.rowPos[cells[j].row - 1] * pen.calculative.worldRect.height) /
                        pen.tableHeight -
                        pen.offsetY * pen.calculative.canvas.store.data.scale;
                    var endY = (pen.rowPos[endIdx] * pen.calculative.worldRect.height) /
                        pen.tableHeight -
                        pen.offsetY * pen.calculative.canvas.store.data.scale;
                    if (startY > pen.calculative.worldRect.height) {
                        //超出最底
                        startY = pen.calculative.worldRect.height;
                    }
                    if (startY >= 0) {
                        ctx.lineTo(pen.calculative.worldRect.x + x_1, pen.calculative.worldRect.y + startY);
                    }
                    if (endY > pen.calculative.worldRect.height) {
                        endY = pen.calculative.worldRect.height;
                    }
                    if (endY >= 0) {
                        ctx.moveTo(pen.calculative.worldRect.x + x_1, pen.calculative.worldRect.y + endY);
                    }
                }
                ctx.lineTo(pen.calculative.worldRect.x + x_1, pen.calculative.worldRect.ey);
            }
            else {
                var x_2 = (item * pen.calculative.worldRect.width) / pen.tableWidth;
                ctx.moveTo(pen.calculative.worldRect.x + x_2, pen.calculative.worldRect.y);
                ctx.lineTo(pen.calculative.worldRect.x + x_2, pen.calculative.worldRect.ey);
            }
            ctx.stroke();
        });
    }
    ctx.restore();
}
function drawActiceCol(ctx, pen) {
    if (pen.calculative.activeCol !== undefined) {
        //绘制选中列
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = pen.activeColor;
        ctx.fillStyle = '#278df833';
        var colRect = getColRect(pen, pen.calculative.activeCol);
        ctx.rect(colRect.x, pen.calculative.worldRect.y, colRect.width, pen.calculative.worldRect.height);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
}
function drawMergeCell(ctx, pen) {
    if (pen.calculative.mergeCell) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = pen.activeColor;
        ctx.fillStyle = '#278df833';
        var rect = getMergeCellRect(pen, pen.calculative.mergeCell);
        ctx.rect(rect.x, rect.y, rect.width, rect.height);
        ctx.fill();
        ctx.stroke();
        ctx.restore();
    }
}
function drawCell(ctx, pen) {
    var _a, _b, _d, _e, _f;
    if (!pen.colPos) {
        return;
    }
    if (!pen.calculative.texts) {
        pen.calculative.texts = [];
    }
    var scale = pen.calculative.canvas.store.data.scale;
    var textScale = 1;
    var _loop_3 = function (i) {
        // if(! pen.calculative.childrenArr[i]){
        //   pen.calculative.childrenArr[i] = [];
        // }
        if (pen.colHeaders && i === 1) {
            //绘制头部
            ctx.save();
            ctx.beginPath();
            var _g = pen.calculative.worldRect, x = _g.x, y = _g.y, width = _g.width, height = _g.height;
            ctx.fillStyle = '#fff0';
            ctx.rect(x - 1, y +
                (pen.rowPos[0] * pen.calculative.worldRect.height) / pen.tableHeight -
                1, width + 2, height -
                (pen.rowPos[0] * pen.calculative.worldRect.height) / pen.tableHeight +
                2);
            ctx.fill();
            ctx.clip();
        }
        var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
        if (i > 0 &&
            pen.offsetY * pen.calculative.canvas.store.data.scale >
                pen.rowPos[i] * scaleY) {
            if (i >= pen.calculative.startIndex) {
                pen.calculative.startIndex = i + 1;
            }
            return "continue";
        }
        if (pen.rowPos[i - 1] * scaleY -
            pen.offsetY * pen.calculative.canvas.store.data.scale >
            pen.calculative.worldRect.height) {
            if (i < pen.calculative.endIndex) {
                pen.calculative.endIndex = i - 1;
            }
            return "continue";
        }
        var rowStyle = getRow(pen, i).style;
        var _loop_4 = function (j) {
            var _h = getCell(pen, i, j), cell = _h.value, cellStyle = _h.style, mergeCell = _h.mergeCell;
            // if(mergeCell){
            //   continue;
            // }
            var isSuccess = true;
            //样式条件成立
            if (cellStyle.wheres &&
                Array.isArray(cellStyle.wheres)) {
                isSuccess = false;
                isSuccess = cellStyle.wheres.every(function (where) {
                    var fn = new Function('attr', "return attr " + where.comparison + " " + where.value);
                    return fn(cell);
                });
            }
            var color = pen.color;
            var textColor = pen.textColor || pen.color;
            var background = null;
            var fontSize = null;
            var fontWeight = null;
            var fontStyle = null;
            if (isSuccess) {
                color =
                    cellStyle.color || rowStyle.color || pen.color;
                textColor =
                    cellStyle.textColor ||
                        rowStyle.textColor ||
                        pen.textColor;
                background =
                    cellStyle.background || rowStyle.background;
                fontSize =
                    (cellStyle.fontSize || rowStyle.fontSize || 0) *
                        pen.calculative.canvas.store.data.scale;
                fontWeight =
                    cellStyle.fontWeight || rowStyle.fontWeight;
                fontStyle = cellStyle.fontStyle || rowStyle.fontStyle;
            }
            var activeColor = void 0;
            if (pen.stripe) {
                if (pen.colHeaders !== false) {
                    if (i % 2 === 1) {
                        background = background || pen.stripeColor || '#407FFF1F';
                    }
                }
                else {
                    if (i % 2 === 0) {
                        background = background || pen.stripeColor || '#407FFF1F';
                    }
                }
            }
            // 选中
            if (pen.calculative.active &&
                ((_a = pen.calculative.activeCell) === null || _a === void 0 ? void 0 : _a.row) === i &&
                ((_b = pen.calculative.activeCell) === null || _b === void 0 ? void 0 : _b.col) === j) {
                color = pen.activeColor;
                background = pen.activeBackground;
                activeColor = color;
                textColor = pen.activeTextColor || pen.activeColor;
            }
            // hover
            if (pen.calculative.hover &&
                ((_d = pen.calculative.hoverCell) === null || _d === void 0 ? void 0 : _d.row) === i &&
                ((_e = pen.calculative.hoverCell) === null || _e === void 0 ? void 0 : _e.col) === j) {
                color = pen.hoverColor;
                background = pen.hoverBackground;
                textColor = pen.hoverTextColor || pen.hoverColor;
                activeColor = color;
            }
            var rect = getCellRect(pen, i, j);
            if (rect.y + rect.height < pen.calculative.worldRect.y ||
                rect.y > pen.calculative.worldRect.height + pen.calculative.worldRect.y) {
                return "continue";
            }
            // 有背景
            if (background) {
                ctx.save();
                ctx.beginPath();
                ctx.fillStyle = background;
                ctx.fillRect(rect.x, rect.y, rect.width + 0.25 * pen.calculative.canvas.store.data.scale, rect.height);
                ctx.restore();
            }
            // 选中或hover
            if (activeColor) {
                ctx.save();
                ctx.beginPath();
                ctx.strokeStyle = activeColor;
                ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
                // ctx.save();
                // ctx.beginPath();
                // ctx.fillStyle = activeColor;
                // ctx.strokeStyle = background;
                // ctx.rect(rect.x+rect.width-5*scale, rect.y+rect.height-5*scale, 5*scale, 5*scale);
                // ctx.fill();
                // ctx.stroke();
                // ctx.restore();
                ctx.restore();
            }
            // 绘画文本
            if (mergeCell) {
                return "continue";
            }
            pen.calculative.worldTextRect = rect;
            var rowText = pen.calculative.texts[i];
            if (!pen.calculative.texts[i]) {
                rowText = [];
                pen.calculative.texts[i] = rowText;
            }
            if (rowText[j] == null) {
                if (typeof cell === 'object') {
                    if (i === 0) {
                        //表头
                        rowText[j] = cell.text;
                    }
                    else {
                        // TODO 配置 {} 代表添加节点 考虑是否有表头
                        var _colPen = pen.styles &&
                            pen.styles.filter(function (item) {
                                return item.col === j && item.row === undefined && item.pens;
                            });
                        if (_colPen.length > 0) {
                            rowText[j] = '';
                            if (pen.isFirstTime) {
                                if (pen.maxNum) {
                                    if (pen.colHeaders && i >= pen.maxNum) {
                                        cell.visible = false;
                                    }
                                }
                                var childrenPen = JSON.parse(JSON.stringify(_colPen[0].pens));
                                childrenPen.forEach(function (item) {
                                    Object.assign(item, { row: i, col: j }, cell);
                                    item.activeBackground = item.background;
                                    item.hoverBackground = item.background;
                                    item.activeColor = item.color;
                                    item.hoverColor = item.color;
                                    item.activeTextColor = item.textColor;
                                    item.hoverTextColor = item.textColor;
                                    item.height *= pen.calculative.canvas.store.data.scale;
                                    item.width *= pen.calculative.canvas.store.data.scale;
                                });
                                calcChildrenRect(pen, rect, childrenPen);
                                pen.calculative.canvas.parent.pushChildren(pen, childrenPen);
                                // pen.calculative.childrenArr[i][j]= childrenPen;
                            }
                            return "continue";
                        }
                    }
                }
                else if (cell === undefined) {
                    rowText[j] = '';
                }
                else {
                    rowText[j] = cell.text || cell + '';
                }
                if (!rowText[j]) {
                    return "continue";
                }
                // 计算换行和省略号
                rowText[j] = calcTextLines(pen, rowText[j]);
            }
            if (!rowText[j]) {
                return "continue";
            }
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = textColor;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.font =
                (fontStyle || pen.calculative.fontStyle || '') +
                    ' normal ' +
                    (fontWeight || pen.calculative.fontWeight || '') +
                    ' ' +
                    (fontSize || pen.calculative.fontSize || 12) * textScale +
                    'px ' +
                    pen.calculative.fontFamily;
            var textAlign = pen.colStyle && ((_f = pen.colStyle[j]) === null || _f === void 0 ? void 0 : _f.textAlign);
            if (textAlign) {
                ctx.textAlign = textAlign;
            }
            if (rowText[j].length === 1) {
                if (textAlign === 'left') {
                    ctx.fillText(rowText[j][0], rect.x, rect.y + rect.height / 2);
                }
                else if (textAlign === 'right') {
                    ctx.fillText(rowText[j][0], rect.x + rect.width, rect.y + rect.height / 2);
                }
                else {
                    ctx.fillText(rowText[j][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
                }
            }
            else {
                var y_2 = 0.55;
                var lineHeight_1 = (fontSize || pen.calculative.fontSize) *
                    pen.calculative.lineHeight *
                    textScale;
                var h = rowText[j].length * lineHeight_1;
                var top_1 = (rect.height - h) / 2;
                if (textAlign === 'left') {
                    rowText[j].forEach(function (text, i) {
                        ctx.fillText(text, rect.x, rect.y + top_1 + (i + y_2) * lineHeight_1);
                    });
                }
                else if (textAlign === 'right') {
                    rowText[j].forEach(function (text, i) {
                        ctx.fillText(text, rect.x + rect.width, rect.y + top_1 + (i + y_2) * lineHeight_1);
                    });
                }
                else {
                    rowText[j].forEach(function (text, i) {
                        ctx.fillText(text, rect.x + rect.width / 2, rect.y + top_1 + (i + y_2) * lineHeight_1);
                    });
                }
            }
            ctx.restore();
        };
        for (var j = 0; j < pen.colPos.length; j++) {
            _loop_4(j);
        }
        if (pen.rowHeaders) {
            //绘制行头
            // if(pen.colHeaders&&i===0){
            //   continue;
            // }
            ctx.save();
            ctx.beginPath();
            ctx.fillStyle = pen.rowHeadersBackground || '#407FFF1F';
            ctx.strokeStyle = pen.rowHeadersColor || '#000';
            var rect = getCellRect(pen, i, -1);
            ctx.rect(rect.x, rect.y, rect.width, rect.height);
            ctx.fill();
            ctx.stroke();
            ctx.font =
                (pen.calculative.fontSize || 12) * textScale +
                    'px ' +
                    pen.calculative.fontFamily;
            ctx.fillStyle = pen.textColor || pen.color;
            ctx.textAlign = 'center';
            ctx.textBaseline = 'middle';
            ctx.fillText(i + '', pen.x + rect.width / 2, rect.y + rect.height / 2);
            ctx.restore();
        }
        if (pen.calculative.activeRow === i) {
            //绘制选中行
            ctx.save();
            ctx.beginPath();
            ctx.strokeStyle = pen.activeColor;
            ctx.fillStyle = '#278df833';
            var rowRect = getRowRect(pen, i);
            ctx.rect(rowRect.x, rowRect.y, rowRect.width, rowRect.height);
            ctx.stroke();
            ctx.fill();
            ctx.restore();
        }
    };
    // if(!pen.calculative.childrenArr){
    //   //存储子节点
    //   pen.calculative.childrenArr = [];
    // }
    for (var i = 0; i < pen.rowPos.length; i++) {
        _loop_3(i);
    }
    // if (pen.calculative.activeCol !== undefined) {
    //   //绘制选中列
    //   ctx.save();
    //   ctx.beginPath();
    //   ctx.strokeStyle = pen.activeColor;
    //   ctx.fillStyle = '#278df833';
    //   const colRect = getColRect(pen, pen.calculative.activeCol);
    //   ctx.rect(
    //     colRect.x,
    //     pen.calculative.worldRect.y,
    //     colRect.width,
    //     pen.calculative.worldRect.height
    //   );
    //   ctx.fill();
    //   ctx.stroke();
    //   ctx.restore();
    // }
}
// 添加table节点回调
function onAdd(pen) {
    var _a;
    createInterval(pen);
    if (!((_a = pen.children) === null || _a === void 0 ? void 0 : _a.length)) {
        pen.isFirstTime = true;
    }
    if (!pen.offsetY) {
        pen.offsetY = 0;
    }
    pen.calculative.startIndex = 0;
    pen.calculative.endIndex = pen.data.length;
    initRect(pen);
}
function onShowInput(pen, e) {
    // 没有活动单元格
    if (!pen.calculative.hoverCell) {
        return;
    }
    if (pen.calculative.hoverCell.row === undefined || pen.calculative.hoverCell.col === undefined) {
        return;
    }
    var _a = getCell(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col), cell = _a.value, mergeCell = _a.mergeCell;
    // 子节点，非文本
    if (typeof cell === 'object') {
        if (pen.calculative.hoverCell.row !== 0) {
            //非表头
            return;
        }
    }
    pen.calculative.isHover = false;
    pen.calculative.isInput = true;
    pen.calculative.canvas.render();
    pen.calculative.inputCell = pen.calculative.hoverCell;
    if (mergeCell) {
        pen.calculative.inputCell = deepClone(mergeCell);
    }
    var rect = getCellRect(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
    pen.calculative.tempText = cell.text || cell + '';
    pen.dropdownList = undefined;
    pen.inputType = undefined;
    if (pen.calculative.hoverCell.row !== 0) {
        var columnCell = pen.data[0][pen.calculative.hoverCell.col];
        if (typeof columnCell === 'object') {
            if (columnCell.type === 'select') {
                pen.dropdownList = columnCell.dropdownList;
            }
            else if (columnCell.type === 'numeric') {
                pen.inputType = 'number';
            }
        }
    }
    pen.calculative.canvas.showInput(pen, rect, '#ffffff');
}
//将输入的数据写入到对应的data中
function onInput(pen, text) {
    if (!pen.calculative.inputCell) {
        return;
    }
    setCellText(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
    pen.calculative.isInput = false;
    pen.calculative.isHover = true;
    pen.calculative.canvas.render();
}
function onMouseMove(pen, e) {
    if (pen.timer) {
        pen.calculative.isHover = false;
        clearTimeout(pen.timer);
    }
    pen.timer = setTimeout(function () {
        pen.calculative.isHover = true;
        pen.calculative.canvas.render();
    }, 500);
    if (pen.calculative.focus && pen.calculative.canvas.externalElements.style.cursor.indexOf('resize') !==
        -1) {
        //移动表格线
        var scale = pen.calculative.canvas.store.data.scale;
        if (pen.calculative.hoverCell.lineCol) {
            // 移动列线
            var gap = e.x - pen.calculative.downPos.x;
            var colV = pen.calculative.hoverCell.lineCol < 2
                ? 0
                : pen.colPos[pen.calculative.hoverCell.lineCol - 2];
            if (pen.colPos[pen.calculative.hoverCell.lineCol - 1] + gap <
                colV + lineGap * 2) {
                //不能超过前一个
                return;
            }
            if (pen.colPos[pen.calculative.hoverCell.lineCol - 1] + gap >
                pen.colPos[pen.calculative.hoverCell.lineCol] - lineGap * 2) {
                //不能超过后一个
                for (var i = pen.calculative.hoverCell.lineCol; i < pen.colPos.length; i++) {
                    pen.colPos[i] += gap;
                    //TODO 这里只是通过第一行判断
                    // if (typeof pen.data[1][i] === 'object') {
                    //   for(let j = 1;j<pen.data.length;j++){
                    //     const rect = getCellRect(pen, j, i);
                    //     calcChildrenRect(pen, rect, pen.calculative.childrenArr[j][i]);
                    //   }
                    // }
                }
                pen.calculative.worldRect.width += gap;
                pen.calculative.width += gap;
                pen.width += gap;
                calcRightBottom(pen.calculative.worldRect);
                calcCenter(pen.calculative.worldRect);
                pen.tableWidth += gap * scale;
                pen.calculative.canvas.activeRect = pen.calculative.worldRect;
            }
            for (var i = 0; i < pen.calculative.texts.length; i++) {
                //重新计算改线上下文字布局
                pen.calculative.texts[i][pen.calculative.hoverCell.lineCol - 1] = null;
                pen.calculative.texts[i][pen.calculative.hoverCell.lineCol] = null;
            }
            pen.colPos[pen.calculative.hoverCell.lineCol - 1] += gap;
            pen.calculative.downPos.x = e.x;
        }
        if (pen.calculative.hoverCell.lineRow) {
            //移动行线
            var gap = e.y - pen.calculative.downPos.y;
            var rowV = pen.calculative.hoverCell.lineRow < 2
                ? 0
                : pen.rowPos[pen.calculative.hoverCell.lineRow - 2];
            if (pen.rowPos[pen.calculative.hoverCell.lineRow - 1] + gap <
                rowV + lineGap * 2) {
                return;
            }
            if (pen.rowPos[pen.calculative.hoverCell.lineRow - 1] + gap >
                pen.rowPos[pen.calculative.hoverCell.lineRow] - lineGap * 2) {
                //不能超过后一个
                for (var i = pen.calculative.hoverCell.lineRow; i < pen.rowPos.length; i++) {
                    pen.rowPos[i] += gap;
                }
                pen.calculative.worldRect.height += gap * scale;
                pen.calculative.height += gap * scale;
                pen.height += gap * scale;
                calcRightBottom(pen.calculative.worldRect);
                calcCenter(pen.calculative.worldRect);
                pen.tableHeight += gap * scale;
            }
            pen.rowPos[pen.calculative.hoverCell.lineRow - 1] += gap;
            pen.calculative.downPos.y = e.y;
        }
        pen.calculative.canvas.render();
        return;
    }
    if (pen.calculative.focus && pen.calculative.canvas.mouseDown) {
        if (pen.calculative.activeCell.row <= 0) {
            //表头不允许合并
            return;
        }
        pen.calculative.hoverCell = getCellIndex(pen, e);
        if (!pen.locked && !pen.calculative.canvas.store.data.locked) {
            if (pen.calculative.activeCell) {
                pen.calculative.mergeCell = getMergeCell(pen);
                pen.calculative.canvas.render();
            }
        }
        return;
    }
    pen.calculative.hoverCell = getCellIndex(pen, e);
    if (pen.calculative.focus && !pen.locked && !pen.calculative.canvas.store.data.locked) {
        if (pen.calculative.hoverCell.lineCol !== undefined) {
            pen.calculative.canvas.externalElements.style.cursor = 'col-resize';
            // pen.calculative.focus = true;
        }
        if (pen.calculative.hoverCell.lineRow !== undefined) {
            pen.calculative.canvas.externalElements.style.cursor = 'row-resize';
            // pen.calculative.focus = true;
        }
        if (pen.calculative.hoverCell.allRow !== undefined) {
            pen.calculative.canvas.externalElements.style.cursor =
                "url(\"" + pen.calculative.canvas.store.options.rightCursor + "\") 8 8, auto";
            // pen.calculative.focus = true;
        }
        if (pen.calculative.hoverCell.allCol !== undefined) {
            pen.calculative.canvas.externalElements.style.cursor = "url(\"" + pen.calculative.canvas.store.options.downCursor + "\") 8 8, auto";
            // pen.calculative.focus = true;
        }
    }
    pen.calculative.canvas.render();
}
function onMouseLeave(pen, e) {
    var _a, _b;
    createInterval(pen);
    // hideScroll(pen);
    (_b = (_a = pen.calculative.singleton) === null || _a === void 0 ? void 0 : _a.tableScroll) === null || _b === void 0 ? void 0 : _b.hideScroll();
    // pen.calculative.singleton?.tableScroll?.destroy();
    // pen.calculative.singleton&&(pen.calculative.singleton.tableScroll = undefined);
    // pen.calculative.hoverCell = undefined;
    //   pen.calculative.activeCell = undefined;
    pen.calculative.canvas.render();
}
function onMouseDown(pen, e) {
    var _a, _b, _d, _e;
    pen.calculative.downPos = deepClone(e);
    pen.calculative.activeCell = getCellIndex(pen, e);
    // pen.calculative.focus = false;
    // if (pen.calculative.activeCell) {
    //   pen.calculative.focus = true;
    // }
    if (pen.calculative.mergeCell &&
        !cellInCell({
            col: pen.calculative.activeCell.col,
            colspan: 1,
            row: pen.calculative.activeCell.row,
            rowspan: 1,
        }, pen.calculative.mergeCell)) {
        pen.calculative.mergeCell = undefined;
    }
    if (pen.calculative.focus &&
        pen.calculative.mergeCell === undefined &&
        pen.calculative.activeCell.allRow === undefined) {
        for (var i = 0; i < ((_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.length); i++) {
            //选中的就是一个合并单元格
            if (cellInCell({
                col: pen.calculative.activeCell.col,
                colspan: 1,
                row: pen.calculative.activeCell.row,
                rowspan: 1,
            }, pen.mergeCells[i])) {
                pen.calculative.mergeCell = deepClone(pen.mergeCells[i]);
            }
        }
    }
    pen.calculative.activeCol = undefined;
    pen.calculative.activeRow = undefined;
    if (!pen.locked && !pen.calculative.canvas.store.data.locked) {
        if ((_b = pen.calculative.singleton) === null || _b === void 0 ? void 0 : _b.tableContextMenu) {
            pen.calculative.singleton.tableContextMenu.hide();
        }
        //选中行
        if (((_d = pen.calculative.hoverCell) === null || _d === void 0 ? void 0 : _d.allRow) !== undefined) {
            pen.calculative.activeRow = pen.calculative.hoverCell.allRow;
            // pen.calculative.focus = true;
        }
        //选中列
        if (((_e = pen.calculative.hoverCell) === null || _e === void 0 ? void 0 : _e.allCol) !== undefined) {
            pen.calculative.activeCol = pen.calculative.hoverCell.allCol;
            // pen.calculative.focus = true;
        }
        if (pen.calculative.mergeCell !== undefined) {
            // pen.calculative.focus = true;
        }
    }
    pen.calculative.canvas.render();
}
// 根据坐标，计算在哪个cell
function getCellIndex(pen, e) {
    var _a, _b;
    var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
    var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
    // const pos: Pos = { row: 0, col: 0 };
    // for (let i = 0; i < pen.colPos.length; i++) {
    //   if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
    //     pos.col = i + 1;
    //   }
    // }
    // for (let i = 0; i < pen.rowPos.length; i++) {
    //   if (
    //     e.y >
    //     pen.calculative.worldRect.y +
    //       pen.rowPos[i] * scaleY -
    //       pen.offsetY * pen.calculative.canvas.store.data.scale
    //   ) {
    //     pos.row = i + 1;
    //   }
    // }
    // return pos;
    var pos = {
        row: undefined,
        col: undefined,
        lineRow: undefined,
        lineCol: undefined,
        allRow: undefined,
        allCol: undefined,
    };
    for (var i = 0; i < pen.colPos.length; i++) {
        var temX = i === 0 ? 0 : pen.colPos[i - 1] * scaleX;
        if (e.x <= pen.calculative.worldRect.x + pen.colPos[i] * scaleX - lineGap &&
            e.x >= pen.calculative.worldRect.x + temX + lineGap) {
            pos.col = i;
        }
        if (i === 0) {
            continue;
        }
        //哪一列线
        if (e.x < pen.calculative.worldRect.x + temX + lineGap &&
            e.x > pen.calculative.worldRect.x + temX - lineGap) {
            pos.lineCol = i;
        }
    }
    var start = pen.calculative.startIndex || 0;
    var end = pen.calculative.endIndex || pen.rowPos.length;
    if (pen.colHeaders) {
        //鼠标移动到表头
        if (e.y < pen.calculative.worldRect.y + pen.rowPos[0] * scaleY) {
            pos.row = 0;
        }
    }
    if (pos.row === undefined) {
        for (var i = start; i <= end; i++) {
            var temY = i === 0 ? 0 : pen.rowPos[i - 1] * scaleY;
            if (e.y <=
                pen.calculative.worldRect.y +
                    pen.rowPos[i] * scaleY -
                    pen.offsetY * pen.calculative.canvas.store.data.scale -
                    lineGap &&
                e.y >=
                    pen.calculative.worldRect.y +
                        temY -
                        pen.offsetY * pen.calculative.canvas.store.data.scale +
                        lineGap) {
                pos.row = i;
            }
            if (i === 0) {
                continue;
            }
            //哪一行线
            // if (!pen.maxNum) {
            //如果有最大行数限制 不允许去调节行
            if (e.y <
                pen.calculative.worldRect.y +
                    temY -
                    pen.offsetY * pen.calculative.canvas.store.data.scale +
                    lineGap &&
                e.y >
                    pen.calculative.worldRect.y +
                        temY -
                        pen.offsetY * pen.calculative.canvas.store.data.scale -
                        lineGap) {
                if (i < pen.rowPos.length) {
                    pos.lineRow = i;
                }
            }
            // }
        }
        //哪一行
        if (e.x <
            pen.calculative.worldRect.x +
                lineGap +
                (pen.colHeaders ? rowHeadersWidth : 0)) {
            pos.allRow = 0;
            for (var i = 0; i < pen.rowPos.length; i++) {
                if (e.y >
                    pen.calculative.worldRect.y +
                        pen.rowPos[i] * scaleY -
                        pen.offsetY * pen.calculative.canvas.store.data.scale) {
                    pos.allRow = i + 1;
                }
            }
        }
    }
    //哪一列
    if (e.y <
        pen.calculative.worldRect.y +
            // - pen.offsetY * pen.calculative.canvas.store.data.scale
            lineGap) {
        pos.allCol = 0;
        for (var i = 0; i < pen.rowPos.length; i++) {
            if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
                pos.allCol = i + 1;
            }
        }
    }
    if (pos.lineCol !== undefined) {
        var cells = [];
        if (pos.row !== undefined) {
            cells = (_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.filter(function (_cells) {
                return _cells.col < pos.lineCol &&
                    pos.lineCol < _cells.col + _cells.colspan &&
                    pos.row >= _cells.row &&
                    pos.row < _cells.row + _cells.rowspan;
            });
        }
        // if(pos.row === undefined){
        //   cells = pen.mergeCells.filter((_cells) => _cells.col < pos.lineCol && pos.lineCol < _cells.col + _cells.colspan);
        // }
        if (pos.lineRow !== undefined) {
            cells = (_b = pen.mergeCells) === null || _b === void 0 ? void 0 : _b.filter(function (_cells) {
                return _cells.col < pos.lineCol &&
                    pos.lineCol < _cells.col + _cells.colspan &&
                    pos.lineRow >= _cells.row &&
                    pos.lineRow < _cells.row + _cells.rowspan;
            });
        }
        if (cells === null || cells === void 0 ? void 0 : cells.length) {
            pos.lineCol = undefined;
            pos.col = cells[0].col;
        }
    }
    if (pen.maxNum) {
        if (pos.lineRow !== undefined) {
            //有行线
            pos.row = pos.lineRow;
        }
        pos.lineRow = undefined;
    }
    return pos;
}
// 根据index获取cell
function getCell(pen, rowIndex, colIndex) {
    var _a;
    if (!pen.data || !Array.isArray(pen.data)) {
        return;
    }
    var cells = (_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.filter(function (_cell) {
        return _cell.row <= rowIndex &&
            _cell.row + _cell.rowspan > rowIndex &&
            _cell.col <= colIndex &&
            _cell.col + _cell.colspan > colIndex;
    });
    var mergeCell = undefined;
    if (cells === null || cells === void 0 ? void 0 : cells.length) {
        //总是取单元格第一个数据
        if (rowIndex !== cells[0].row || colIndex !== cells[0].col) {
            mergeCell = {
                row: cells[0].row,
                col: cells[0].col,
            };
        }
        rowIndex = cells[0].row;
        colIndex = cells[0].col;
    }
    var row = pen.data[rowIndex];
    //TODO 没有获取单独设置 某行 某列 的样式
    var style = pen.styles &&
        pen.styles.filter(function (item) {
            return item.row === rowIndex && item.col === colIndex;
        });
    if (Array.isArray(row)) {
        return {
            value: row[colIndex],
            style: (style === null || style === void 0 ? void 0 : style.length) > 0 ? style[0] : {},
            mergeCell: mergeCell,
        };
    }
    else if (!row.data || !Array.isArray(row.data)) {
        return;
    }
}
// 根据index获取getRow
function getRow(pen, rowIndex) {
    if (!pen.data || !Array.isArray(pen.data)) {
        return;
    }
    var row = pen.data[rowIndex];
    //TODO 没有获取单独设置 某行 某列 的样式
    var style = pen.styles &&
        pen.styles.filter(function (item) {
            return item.row === rowIndex && !item.col;
        });
    if (Array.isArray(row)) {
        return { value: row, style: (style === null || style === void 0 ? void 0 : style.length) > 0 ? style[0] : {} };
    }
    else if (!row.data || !Array.isArray(row.data)) {
        return;
    }
}
function getMergeCell(pen) {
    // let mergeCell = {
    //   row: pen.calculative.activeCell.row,
    //   col: pen.calculative.activeCell.col,
    //   rowspan: pen.calculative.hoverCell.row - pen.calculative.activeCell.row + 1,
    //   colspan: pen.calculative.hoverCell.col - pen.calculative.activeCell.col + 1,
    // };
    var hoverCell = deepClone(pen.calculative.hoverCell);
    //保证hover格式正确
    if (!hoverCell.col) {
        hoverCell.col = hoverCell.lineCol || 0;
    }
    if (!hoverCell.row) {
        hoverCell.row = hoverCell.lineRow;
    }
    var mergeCell = getBoundingCell([
        __assign(__assign({}, pen.calculative.activeCell), { rowspan: 1, colspan: 1 }),
        __assign(__assign({}, hoverCell), { rowspan: 1, colspan: 1 }),
    ]);
    //框选区域包含合并过的单元格
    // if(pen.mergeCells){
    //   let cells = pen.mergeCells.filter((_cell)=>{
    //     return cellOverlap(mergeCell,_cell);
    //   });
    //   if(cells.length){
    //     mergeCell = getBoundingCell([mergeCell,...cells]);
    //   }
    // }
    if (pen.mergeCells) {
        mergeCell = deepMergeCell(pen, mergeCell);
    }
    return mergeCell;
}
function deepMergeCell(pen, mergeCell) {
    var _a;
    var cells = (_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.filter(function (_cell) {
        return cellOverlap(_cell, mergeCell);
    });
    if (cells === null || cells === void 0 ? void 0 : cells.length) {
        // mergeCell = getBoundingCell([mergeCell,...cells])
        //TODO 1
        return deepMergeCell(pen, getBoundingCell(__spreadArray([mergeCell], __read(cells), false)));
    }
    else {
        return mergeCell;
    }
}
//cell是否有重叠
function cellOverlap(cell1, cell2) {
    if (cell1.row + cell1.rowspan <= cell2.row) {
        return false;
    }
    if (cell1.row >= cell2.row + cell2.rowspan) {
        return false;
    }
    if (cell1.col + cell1.colspan <= cell2.col) {
        return false;
    }
    if (cell1.col >= cell2.col + cell2.colspan) {
        return false;
    }
    if (cellInCell(cell1, cell2)) {
        return false;
    }
    return true;
}
//cell1是否在cell2中
function cellInCell(cell1, cell2) {
    if (cell1.row >= cell2.row &&
        cell1.row + cell1.rowspan <= cell2.row + cell2.rowspan &&
        cell1.col >= cell2.col &&
        cell1.col + cell1.colspan <= cell2.col + cell2.colspan) {
        return true;
    }
    return false;
}
// 获取合并单元格的边界
function getBoundingCell(cells) {
    var minX = cells[0].col;
    var minY = cells[0].row;
    var maxX = cells[0].col + cells[0].colspan;
    var maxY = cells[0].row + cells[0].rowspan;
    cells.forEach(function (cell) {
        minX = Math.min(minX, cell.col);
        minY = Math.min(minY, cell.row);
        maxX = Math.max(maxX, cell.col + cell.colspan);
        maxY = Math.max(maxY, cell.row + cell.rowspan);
    });
    return { col: minX, row: minY, colspan: maxX - minX, rowspan: maxY - minY };
}
// 设置cell的文本
function setCellText(pen, rowIndex, colIndex, text) {
    if (!pen.data || !Array.isArray(pen.data)) {
        return;
    }
    pen.isFirstTime = false;
    pen.calculative.texts = undefined;
    var rowData = pen.data[rowIndex];
    if (!rowData) {
        return;
    }
    if (rowData[colIndex] instanceof Object) {
        rowData[colIndex].text = text;
    }
    else {
        rowData[colIndex] = text;
    }
    pen.calculative.canvas.store.emitter.emit('valueUpdate', pen);
}
// 计算cell世界坐标区域
function getCellRect(pen, rowIndex, colIndex) {
    var _a;
    var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
    var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
    var cells = (_a = pen.mergeCells) === null || _a === void 0 ? void 0 : _a.filter(function (item) {
        return item.col <= colIndex &&
            item.row <= rowIndex &&
            item.col + item.colspan > colIndex &&
            item.row + item.rowspan > rowIndex;
    });
    var x = 0;
    var ex = 0;
    if (colIndex > -1) {
        ex = pen.colPos[colIndex] * scaleX;
    }
    else if (colIndex === -1) {
        if (pen.rowHeaders) {
            ex = rowHeadersWidth * scaleX;
        }
        else {
            ex = 0;
        }
    }
    if (colIndex > 0) {
        x = pen.colPos[colIndex - 1] * scaleX;
    }
    if (colIndex === 0 && pen.rowHeaders) {
        x = rowHeadersWidth * scaleX;
    }
    if (cells === null || cells === void 0 ? void 0 : cells.length) {
        if (cells[0].col < 1) {
            if (pen.rowHeaders) {
                x = rowHeadersWidth * scaleX;
            }
            else {
                x = 0;
            }
        }
        else {
            x = pen.colPos[cells[0].col - 1] * scaleX;
        }
        var endIdx = cells[0].col + cells[0].colspan - 1;
        if (endIdx >= pen.colPos.length) {
            endIdx = pen.colPos.length - 1;
        }
        ex = pen.colPos[endIdx] * scaleX;
    }
    var y = 0;
    var ey = pen.rowPos[rowIndex] * scaleY;
    if (rowIndex > 0) {
        y = pen.rowPos[rowIndex - 1] * scaleY;
    }
    if (cells === null || cells === void 0 ? void 0 : cells.length) {
        y = pen.rowPos[cells[0].row - 1] * scaleY;
        var endIdx = cells[0].row + cells[0].rowspan - 1;
        if (endIdx >= pen.rowPos.length) {
            endIdx = pen.rowPos.length - 1;
        }
        ey = pen.rowPos[endIdx] * scaleY;
    }
    var offset = pen.offsetY * pen.calculative.canvas.store.data.scale;
    if (rowIndex === 0 && pen.colHeaders) {
        offset = 0;
    }
    return {
        x: pen.calculative.worldRect.x + x,
        y: pen.calculative.worldRect.y + y - offset,
        ex: pen.calculative.worldRect.x + ex,
        ey: pen.calculative.worldRect.y + ey - offset,
        width: ex - x,
        height: ey - y,
    };
}
function getColRect(pen, colIndex) {
    var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
    var x = 0;
    if (pen.rowHeaders) {
        x = rowHeadersWidth * scaleX;
    }
    var ex = pen.colPos[colIndex] * scaleX;
    if (colIndex > 0) {
        x = pen.colPos[colIndex - 1] * scaleX;
    }
    return {
        x: pen.calculative.worldRect.x + x,
        y: pen.calculative.worldRect.y,
        ex: pen.calculative.worldRect.x + ex,
        ey: pen.calculative.worldRect.ey,
        width: ex - x,
        height: pen.calculative.worldRect.height,
    };
}
function getRowRect(pen, rowIndex) {
    // const scaleX = pen.calculative.worldRect.width / pen.tableWidth;
    var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
    var y = 0;
    var ey = pen.rowPos[rowIndex] * scaleY;
    if (rowIndex > 0) {
        y = pen.rowPos[rowIndex - 1] * scaleY;
    }
    var offset = pen.offsetY * pen.calculative.canvas.store.data.scale;
    if (rowIndex === 0 && pen.colHeaders) {
        offset = 0;
    }
    return {
        x: pen.calculative.worldRect.x,
        y: pen.calculative.worldRect.y + y - offset,
        ex: pen.calculative.worldRect.ex,
        ey: pen.calculative.worldRect.y + ey - offset,
        width: pen.calculative.worldRect.width,
        height: ey - y,
    };
}
function getMergeCellRect(pen, mergeCell) {
    var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
    var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
    var x = pen.colPos[mergeCell.col - 1] * scaleX;
    if (mergeCell.col === 0) {
        x = 0;
        if (pen.rowHeaders) {
            x = rowHeadersWidth * scaleX;
        }
    }
    var ex = pen.colPos[mergeCell.col + mergeCell.colspan - 1] * scaleX;
    var y = pen.rowPos[mergeCell.row - 1] * scaleY;
    // if()
    var ey = pen.rowPos[mergeCell.row + mergeCell.rowspan - 1] * scaleY;
    var offset = pen.offsetY * pen.calculative.canvas.store.data.scale;
    // if (mergeCell === 0 && pen.colHeaders) {
    //   offset = 0;
    // }
    return {
        x: pen.calculative.worldRect.x + x,
        y: pen.calculative.worldRect.y + y - offset,
        ex: pen.calculative.worldRect.x + ex,
        ey: pen.calculative.worldRect.y + ey - offset,
        width: ex - x,
        height: ey - y,
    };
}
// 计算cell子节点的世界坐标区域
function calcChildrenRect(pen, rect, children) {
    var e_1, _a, e_2, _b;
    var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
    var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
    var resizeX = 1;
    var resizeY = 1;
    if (pen.initWorldRect) {
        if (pen.calculative.worldRect.width !== pen.initWorldRect.width) {
            resizeX = pen.calculative.worldRect.width / pen.initWorldRect.width;
        }
        if (pen.calculative.worldRect.height !== pen.initWorldRect.height) {
            resizeY = pen.calculative.worldRect.height / pen.initWorldRect.height;
        }
    }
    // 计算子节点需要的宽高
    var height = 0;
    var lastX = 0;
    var lastY = 0;
    var scale = pen.calculative.canvas.store.data.scale;
    if (children.length > 1) {
        try {
            for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
                var item = children_1_1.value;
                if (lastX + item.width * scaleX + 20 * scale * scaleX < rect.width) {
                    item.x = rect.x + lastX + 10 * scale * scaleX;
                    item.y = rect.y + lastY + 10 * scale * scaleY;
                    lastX += (item.width + 10 * scale) * scaleX;
                    height = Math.max(height, lastY + (item.height + 10 * scale) * scaleY);
                }
                else {
                    // 超出需要换行
                    lastX = 0;
                    lastY = height;
                    item.x = rect.x + lastX + 10 * scale * scaleX;
                    item.y = rect.y + lastY + 10 * scale * scaleY;
                    height += (item.height + 10 * scale) * scaleY;
                }
            }
        }
        catch (e_1_1) { e_1 = { error: e_1_1 }; }
        finally {
            try {
                if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
            }
            finally { if (e_1) throw e_1.error; }
        }
        // 垂直居中
        if (height + 20 * scale * scaleY < rect.height) {
            var top_2 = (rect.height - height - 10 * scale * scaleY) / 2;
            try {
                for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
                    var item = children_2_1.value;
                    item.y += top_2;
                }
            }
            catch (e_2_1) { e_2 = { error: e_2_1 }; }
            finally {
                try {
                    if (children_2_1 && !children_2_1.done && (_b = children_2.return)) _b.call(children_2);
                }
                finally { if (e_2) throw e_2.error; }
            }
        }
    }
    else {
        //一个子图元默认水平垂直居中
        children[0].x = rect.x + (rect.width - children[0].width) / 2;
        children[0].y = rect.y + (rect.height - children[0].height) / 2;
    }
    children.forEach(function (item) {
        item.width = (item.width * resizeX) / scale;
        item.height = (item.height * resizeY) / scale;
    });
}
function onValue(pen) {
    if (pen.calculative.isUpdateData) {
        delete pen.calculative.isUpdateData;
        var temChildren = deepClone(pen.children);
        pen.children = [];
        onAdd(pen);
        temChildren &&
            temChildren.forEach(function (child) {
                pen.calculative.canvas.delForce(pen.calculative.canvas.findOne(child));
            });
        pen.calculative.texts = undefined;
        // pen.calculative.canvas.active([pen]);
    }
}
function beforeValue(pen, value) {
    var e_3, _a;
    pen.calculative.isUpdateData = false;
    if (pen.swiper !== undefined) {
        if (pen.swiper) {
            createInterval(pen);
        }
        else {
            delInterval(pen);
        }
    }
    if (value.styles) {
        pen.initWorldRect = undefined;
    }
    if (value.table ||
        (value.col == undefined && value.row == undefined)) {
        if (value.dataY) {
            var replaceMode = pen.replaceMode;
            var data_1 = [];
            if (!replaceMode) {
                //追加
                data_1 = pen.data.concat(value.dataY);
            }
            else if (replaceMode === ReplaceMode.Replace) {
                //替换
                data_1 = pen.data;
                value.dataX &&
                    value.dataX.forEach(function (item, index) {
                        data_1[item] = value.dataY[index];
                    });
            }
            else if (replaceMode === ReplaceMode.ReplaceAll) {
                //替换指定
                if (value.dataX) {
                    data_1[0] = value.dataX;
                }
                else {
                    data_1[0] = pen.data[0];
                }
                data_1 = data_1.concat(value.dataY);
            }
            delete value.dataX;
            delete value.dataY;
            pen.calculative.isUpdateData = true;
            return Object.assign(value, { data: data_1 });
        }
        if (value.data || value.styles || value.maxNum) {
            pen.calculative.isUpdateData = true;
        }
        try {
            for (var _b = __values(Object.keys(value)), _d = _b.next(); !_d.done; _d = _b.next()) {
                var key = _d.value;
                if (key.includes('data.')) {
                    pen.calculative.isUpdateData = true;
                }
            }
        }
        catch (e_3_1) { e_3 = { error: e_3_1 }; }
        finally {
            try {
                if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
            }
            finally { if (e_3) throw e_3.error; }
        }
        return value;
    }
    var rowData = pen.data[value.row];
    if (!rowData) {
        return value;
    }
    if (rowData[value.col] instanceof Object) {
    }
    else {
        rowData[value.col] = value.value;
    }
    setCellText(pen, value.row, value.col, value.value);
    pen.calculative.canvas.render();
    delete value.col;
    delete value.row;
    return value;
}
//鼠标滚动
function onWheel(pen, e) {
    var _a, _b;
    if (!pen.locked && !pen.calculative.canvas.store.data.locked) {
        return;
    }
    if (!pen.maxNum) {
        return;
    }
    var offset = 0;
    if (e.deltaY > 0) {
        offset = 4;
    }
    else {
        offset = -4;
    }
    scroll(pen, offset);
    // updataScrollHTop(pen);
    (_b = (_a = pen.calculative.singleton) === null || _a === void 0 ? void 0 : _a.tableScroll) === null || _b === void 0 ? void 0 : _b.updataScrollHTop();
}
//滚动处理
function scroll(pen, offset) {
    var _a;
    pen.calculative.startIndex = 0;
    pen.calculative.endIndex = pen.data.length;
    if (!pen.offsetY) {
        pen.offsetY = 0;
    }
    pen.offsetY += offset;
    var timesY = pen.calculative.worldRect.height / pen.initWorldRect.height;
    //滚动的最大偏移值
    if (pen.offsetY > pen.calculative.maxOffsetY * timesY) {
        pen.offsetY = pen.calculative.maxOffsetY * timesY;
    }
    if (pen.offsetY < 0) {
        pen.offsetY = 0;
    }
    //子节点
    (_a = pen.children) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
        var _pen = pen.calculative.canvas.store.pens[item];
        changeChildVisible(pen, _pen);
    });
    pen.calculative.canvas.render();
}
//控制子节点
function changeChildVisible(pen, _pen) {
    if (!_pen) {
        return;
    }
    if (!_pen.oldY) {
        _pen.oldY = _pen.y;
    }
    var _a = _pen.calculative.worldRect, y = _a.y, height = _a.height;
    var _b = pen.calculative.worldRect, penY = _b.y, penH = _b.height;
    var scale = pen.calculative.canvas.store.data.scale;
    var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
    var rowHeight = pen.rowHeight; //*scale;
    //y值更新
    _pen.y = _pen.oldY - (pen.offsetY * scale) / pen.calculative.worldRect.height;
    var oldOffset = ((rowHeight * (pen.initScale || 1)) / pen.tableHeight) * pen.maxNum;
    pen.calculative.canvas.updatePenRect(_pen);
    if (pen.colHeaders) {
        if (_pen.y < pen.rowPos[0] / pen.tableHeight) {
            //显示/隐藏
            _pen.calculative.visible = false;
            _pen.visible = false;
            //颜色及位置更新
            if (_pen.y < pen.rowPos[0] / pen.tableHeight / 2) {
                _pen.oldY += oldOffset;
                var row = _pen.row + pen.maxNum;
                if (!pen.data[row]) {
                    return;
                }
                var rowStyle = deepClone(pen.data[row][_pen.col]);
                if (rowStyle.background) {
                    rowStyle.activeBackground = rowStyle.background;
                    rowStyle.hoverBackground = rowStyle.background;
                }
                if (rowStyle.color) {
                    rowStyle.hoverColor = rowStyle.color;
                    rowStyle.activeColor = rowStyle.color;
                }
                if (rowStyle.textColor) {
                    rowStyle.activeTextColor = rowStyle.textColor;
                    rowStyle.hoverTextColor = rowStyle.textColor;
                }
                Object.assign(_pen, rowStyle, { row: row });
                Object.assign(_pen.calculative, rowStyle, { row: row });
            }
        }
        else if (_pen.y + _pen.height > 1) {
            //显示/隐藏
            _pen.calculative.visible = false;
            _pen.visible = false;
            //颜色及位置更新
            if (_pen.y + _pen.height / 2 > 1) {
                _pen.oldY -= oldOffset;
                var row = _pen.row - pen.maxNum;
                if (!pen.data[row]) {
                    return;
                }
                var rowStyle = deepClone(pen.data[row][_pen.col]);
                if (rowStyle.background) {
                    rowStyle.activeBackground = rowStyle.background;
                    rowStyle.hoverBackground = rowStyle.background;
                }
                if (rowStyle.color) {
                    rowStyle.hoverColor = rowStyle.color;
                    rowStyle.activeColor = rowStyle.color;
                }
                if (rowStyle.textColor) {
                    rowStyle.activeTextColor = rowStyle.textColor;
                    rowStyle.hoverTextColor = rowStyle.textColor;
                }
                Object.assign(_pen, rowStyle, { row: row });
                Object.assign(_pen.calculative, rowStyle, { row: row });
            }
        }
        else {
            _pen.visible = true;
            _pen.calculative.visible = true;
        }
    }
    else {
        if (_pen.y < 0) {
            _pen.calculative.visible = false;
            _pen.visible = false;
            if (_pen.y < -rowHeight / pen.tableHeight / 2) {
                _pen.oldY += oldOffset;
                var row = _pen.row + pen.maxNum;
                if (!pen.data[row]) {
                    return;
                }
                var rowStyle = deepClone(pen.data[row][_pen.col]);
                if (rowStyle.background) {
                    rowStyle.activeBackground = rowStyle.background;
                    rowStyle.hoverBackground = rowStyle.background;
                }
                if (rowStyle.color) {
                    rowStyle.hoverColor = rowStyle.color;
                    rowStyle.activeColor = rowStyle.color;
                }
                if (rowStyle.textColor) {
                    rowStyle.activeTextColor = rowStyle.textColor;
                    rowStyle.hoverTextColor = rowStyle.textColor;
                }
                Object.assign(_pen, rowStyle, { row: row });
                Object.assign(_pen.calculative, rowStyle, { row: row });
            }
        }
        else if (_pen.y + _pen.height > 1) {
            _pen.calculative.visible = false;
            _pen.visible = false;
            if (_pen.y + _pen.height / 2 > 1) {
                _pen.oldY -= oldOffset;
                var row = _pen.row - pen.maxNum;
                if (!pen.data[row]) {
                    return;
                }
                var rowStyle = deepClone(pen.data[row][_pen.col]);
                if (rowStyle.background) {
                    rowStyle.activeBackground = rowStyle.background;
                    rowStyle.hoverBackground = rowStyle.background;
                }
                if (rowStyle.color) {
                    rowStyle.hoverColor = rowStyle.color;
                    rowStyle.activeColor = rowStyle.color;
                }
                if (rowStyle.textColor) {
                    rowStyle.activeTextColor = rowStyle.textColor;
                    rowStyle.hoverTextColor = rowStyle.textColor;
                }
                Object.assign(_pen, rowStyle, { row: row });
                Object.assign(_pen.calculative, rowStyle, { row: row });
            }
        }
        else {
            _pen.calculative.visible = true;
            _pen.visible = true;
        }
    }
}
function onDestroy(pen) {
    var _a, _b, _d, _e;
    (_b = (_a = pen.calculative.singleton) === null || _a === void 0 ? void 0 : _a.tableScroll) === null || _b === void 0 ? void 0 : _b.destroy();
    (_e = (_d = pen.calculative.singleton) === null || _d === void 0 ? void 0 : _d.tableContextMenu) === null || _e === void 0 ? void 0 : _e.destroy();
    delInterval(pen);
}
function delInterval(pen) {
    if (pen.interval) {
        globalThis.clearInterval(pen.interval);
        pen.interval = null;
    }
}
function createInterval(pen) {
    if (pen.maxNum && pen.swiper) {
        if (pen.interval) {
            return;
        }
        pen.interval = globalThis.setInterval(function () {
            if (pen.offsetY >= pen.calculative.maxOffsetY) {
                pen.offsetY = 0;
                initChildrenStyle(pen);
            }
            else {
                if (!(pen.offsetY % pen.rowHeight)) {
                    //完整一行 停顿
                    if (!pen.calculative.stap) {
                        pen.calculative.stap = 0;
                    }
                    pen.calculative.stap += 1;
                    if (pen.calculative.stap == 12) {
                        pen.calculative.stap = 0;
                        scroll(pen, 1);
                    }
                }
                else {
                    scroll(pen, 1);
                }
            }
        }, 50);
    }
}
function initChildrenStyle(pen) {
    var _a;
    (_a = pen.children) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
        var rowHeight = pen.rowHeight; //*scale;
        var _pen = pen.calculative.canvas.store.pens[item];
        if (!_pen) {
            return;
        }
        var oldOffset = ((rowHeight * (pen.initScale || 1)) / pen.tableHeight) * pen.maxNum;
        _pen.oldY -= oldOffset;
        var row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
            return;
        }
        var rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
            rowStyle.activeBackground = rowStyle.background;
            rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
            rowStyle.hoverColor = rowStyle.color;
            rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
            rowStyle.activeTextColor = rowStyle.textColor;
            rowStyle.hoverTextColor = rowStyle.textColor;
        }
        _pen.calculative.visible = true;
        _pen.visible = true;
        Object.assign(_pen, rowStyle, { row: row });
        Object.assign(_pen.calculative, rowStyle, { row: row });
    });
    pen.calculative.canvas.render();
}
function onMouseEnter(pen) {
    delInterval(pen);
    if (pen.maxNum && (pen.locked || pen.calculative.canvas.store.data.locked)) {
        // generateScroll(pen);
        if (!pen.calculative.singleton) {
            pen.calculative.singleton = {};
        }
        if (!pen.calculative.singleton.tableScroll) {
            pen.calculative.singleton.tableScroll = new TableScroll(pen);
        }
        pen.calculative.singleton.tableScroll.showScroll();
    }
}
function onContextmenu(pen, e) {
    if (!pen.calculative.singleton) {
        pen.calculative.singleton = {};
    }
    if (!pen.calculative.singleton.tableContextMenu) {
        pen.calculative.singleton.tableContextMenu = new TableContextMenu(pen);
    }
    if (pen.calculative.mergeCell !== undefined) {
        pen.calculative.singleton.tableContextMenu.updateMenu('merge', e);
    }
    if (pen.calculative.activeRow !== undefined) {
        pen.calculative.singleton.tableContextMenu.updateMenu('row', e);
    }
    if (pen.calculative.activeCol !== undefined) {
        pen.calculative.singleton.tableContextMenu.updateMenu('col', e);
    }
}
function onResize(pen) {
    var _a, _b;
    (_b = (_a = pen.calculative.singleton) === null || _a === void 0 ? void 0 : _a.tableScroll) === null || _b === void 0 ? void 0 : _b.updataScroll();
}
function onMove(pen) {
    var _a, _b;
    (_b = (_a = pen.calculative.singleton) === null || _a === void 0 ? void 0 : _a.tableScroll) === null || _b === void 0 ? void 0 : _b.updataScroll();
}
var contextmenu = {
    col: [
        {
            name: '左插入列',
            key: 'insertColLeft',
            disabled: false,
        },
        {
            name: '右插入列',
            key: 'insertColRight',
            disabled: false,
        },
        {
            name: '删除列',
            key: 'deleteCol',
        },
        {
            name: '清空列',
            key: 'clearCol',
        },
    ],
    row: [
        {
            name: '上插入行',
            key: 'insertRowAbove',
            disabled: false,
        },
        {
            name: '下插入行',
            key: 'insertRowBelow',
            disabled: false,
        },
        {
            name: '删除行',
            key: 'deleteRow',
        },
        {
            name: '清空行',
            key: 'clearRow',
        },
    ],
    merge: [
        {
            name: '清空单元格',
            key: 'clearCells',
        },
        {
            name: '取消合并',
            key: 'cancelMerge',
        },
        {
            name: '合并',
            key: 'mergeCell',
        },
    ],
};
var TableContextMenu = /** @class */ (function () {
    function TableContextMenu(pen) {
        var _this = this;
        this.insertColLeft = function (colIndex) {
            var _a, _b, _d;
            _this.pen.data.forEach(function (item) {
                item.splice(colIndex, 0, '');
            });
            var colWidth = _this.pen.colWidth;
            if (colIndex !== 0) {
                colWidth = _this.pen.colPos[colIndex - 1] + _this.pen.colWidth;
            }
            _this.pen.colPos.splice(colIndex, 0, colWidth);
            for (var i = colIndex + 1; i < _this.pen.colPos.length; i++) {
                _this.pen.colPos[i] += _this.pen.colWidth;
            }
            _this.pen.tableWidth += _this.pen.colWidth;
            _this.pen.calculative.worldRect.width += _this.pen.colWidth;
            _this.pen.calculative.worldRect.center.x += _this.pen.colWidth / 2;
            _this.pen.calculative.worldRect.ex += _this.pen.colWidth;
            _this.pen.initWorldRect.width += _this.pen.colWidth;
            (_a = _this.pen.styles) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
                if (item.col >= colIndex) {
                    item.col += 1;
                }
            });
            _this.pen.calculative.activeCol += 1;
            //有合并单元格
            if ((_b = _this.pen.mergeCells) === null || _b === void 0 ? void 0 : _b.length) {
                (_d = _this.pen.mergeCells) === null || _d === void 0 ? void 0 : _d.forEach(function (item) {
                    if (item.col < colIndex && colIndex < item.col + item.colspan) {
                        item.colspan += 1;
                    }
                    if (item.col >= colIndex) {
                        item.col += 1;
                    }
                });
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.insertColRight = function (colIndex) {
            var _a, _b, _d;
            _this.pen.data.forEach(function (item) {
                item.splice(colIndex + 1, 0, '');
            });
            _this.pen.colPos.splice(colIndex + 1, 0, _this.pen.colPos[colIndex] + _this.pen.colWidth);
            for (var i = colIndex + 2; i < _this.pen.colPos.length; i++) {
                _this.pen.colPos[i] += _this.pen.colWidth;
            }
            _this.pen.tableWidth += _this.pen.colWidth;
            _this.pen.calculative.worldRect.width += _this.pen.colWidth;
            _this.pen.calculative.worldRect.center.x += _this.pen.colWidth / 2;
            _this.pen.calculative.worldRect.ex += _this.pen.colWidth;
            _this.pen.initWorldRect.width += _this.pen.colWidth;
            (_a = _this.pen.styles) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
                if (item.col >= colIndex) {
                    item.col += 1;
                }
            });
            if ((_b = _this.pen.mergeCells) === null || _b === void 0 ? void 0 : _b.length) {
                (_d = _this.pen.mergeCells) === null || _d === void 0 ? void 0 : _d.forEach(function (item) {
                    if (item.col < colIndex + 1 && colIndex + 1 < item.col + item.colspan) {
                        item.colspan += 1;
                    }
                    if (item.col >= colIndex + 1) {
                        item.col += 1;
                    }
                });
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.deleteCol = function (colIndex) {
            var _a, _b, _d;
            _this.pen.data.forEach(function (item) {
                item.splice(colIndex, 1);
            });
            var colWidth = _this.pen.colPos[colIndex] - _this.pen.colPos[colIndex - 1];
            if (colIndex === 0) {
                colWidth = _this.pen.colPos[colIndex];
            }
            _this.pen.colPos.splice(colIndex, 1);
            for (var i = colIndex; i < _this.pen.colPos.length; i++) {
                _this.pen.colPos[i] -= colWidth;
            }
            _this.pen.tableWidth -= colWidth;
            _this.pen.calculative.worldRect.width -= colWidth;
            _this.pen.calculative.worldRect.center.x -= colWidth / 2;
            _this.pen.calculative.worldRect.ex -= colWidth;
            _this.pen.initWorldRect.width -= colWidth;
            (_a = _this.pen.styles) === null || _a === void 0 ? void 0 : _a.forEach(function (item) {
                if (item.col >= colIndex) {
                    item.col -= 1;
                }
            });
            if ((_b = _this.pen.mergeCells) === null || _b === void 0 ? void 0 : _b.length) {
                for (var i = 0; i < ((_d = _this.pen.mergeCells) === null || _d === void 0 ? void 0 : _d.length); i++) {
                    var item = _this.pen.mergeCells[i];
                    if (item.col <= colIndex && colIndex < item.col + item.colspan) {
                        item.colspan -= 1;
                    }
                    if (item.col > colIndex) {
                        item.col -= 1;
                    }
                    if (item.colspan < 1 || (item.colspan === 1 && item.rowspan === 1)) {
                        _this.pen.mergeCells.splice(i, 1);
                        i--;
                    }
                }
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.clearCol = function (colIndex) {
            _this.pen.data.forEach(function (item) {
                item[colIndex] = '';
            });
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.insertRowAbove = function (rowIndex) {
            var _a;
            var row = [];
            for (var i = 0; i < _this.pen.colPos.length; i++) {
                row.push('');
            }
            //数据
            _this.pen.data.splice(rowIndex, 0, row);
            //行位置
            _this.pen.rowPos.splice(rowIndex, 0, _this.pen.rowPos[rowIndex - 1] + _this.pen.rowHeight);
            for (var i = rowIndex + 1; i < _this.pen.rowPos.length; i++) {
                _this.pen.rowPos[i] += _this.pen.rowHeight;
            }
            if (_this.pen.maxNum) {
                _this.pen.calculative.maxOffsetY +=
                    _this.pen.rowHeight * _this.pen.calculative.canvas.store.data.scale;
            }
            else {
                _this.pen.tableHeight += _this.pen.rowHeight;
                _this.pen.height += _this.pen.rowHeight;
                _this.pen.calculative.worldRect.height += _this.pen.rowHeight;
                _this.pen.calculative.worldRect.center.y += _this.pen.rowHeight / 2;
                _this.pen.calculative.worldRect.ey += _this.pen.rowHeight;
                _this.pen.initWorldRect.height += _this.pen.rowHeight;
                _this.pen.calculative.endIndex += 1;
            }
            _this.pen.calculative.activeRow += 1;
            //有合并单元格情况
            if ((_a = _this.pen.mergeCells) === null || _a === void 0 ? void 0 : _a.length) {
                _this.pen.mergeCells.forEach(function (item) {
                    // 合并之间 增加
                    if (item.row < rowIndex && rowIndex < item.row + item.rowspan) {
                        item.rowspan += 1;
                    }
                    //合并之前 下移一位
                    if (item.row >= rowIndex) {
                        item.row += 1;
                    }
                });
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.insertRowBelow = function (rowIndex) {
            var _a;
            var row = [];
            for (var i = 0; i < _this.pen.colPos.length; i++) {
                row.push('');
            }
            _this.pen.data.splice(rowIndex + 1, 0, row);
            //TODO initRect?
            var pos = _this.pen.rowPos[rowIndex + 1];
            if (rowIndex === _this.pen.rowPos.length - 1) {
                pos = _this.pen.rowPos[rowIndex] + _this.pen.rowHeight;
            }
            _this.pen.rowPos.splice(rowIndex + 1, 0, pos);
            for (var i = rowIndex + 2; i < _this.pen.rowPos.length; i++) {
                _this.pen.rowPos[i] += _this.pen.rowHeight;
            }
            // this.pen.tableHeight += this.pen.rowHeight;
            if (_this.pen.maxNum) {
                _this.pen.calculative.maxOffsetY +=
                    _this.pen.rowHeight * _this.pen.calculative.canvas.store.data.scale;
            }
            else {
                _this.pen.tableHeight += _this.pen.rowHeight;
                _this.pen.height += _this.pen.rowHeight;
                _this.pen.calculative.worldRect.height += _this.pen.rowHeight;
                _this.pen.calculative.worldRect.center.y += _this.pen.rowHeight / 2;
                _this.pen.calculative.worldRect.ey += _this.pen.rowHeight;
                _this.pen.initWorldRect.height += _this.pen.rowHeight;
                _this.pen.calculative.endIndex += 1;
            }
            //有合并单元格情况
            if ((_a = _this.pen.mergeCells) === null || _a === void 0 ? void 0 : _a.length) {
                _this.pen.mergeCells.forEach(function (item) {
                    //合并之间 增加
                    if (item.row < rowIndex + 1 && rowIndex + 1 < item.row + item.rowspan) {
                        item.rowspan += 1;
                    }
                    //合并之前 下移一位
                    if (item.row >= rowIndex + 1) {
                        item.row += 1;
                    }
                });
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.deleteRow = function (rowIndex) {
            var _a;
            _this.pen.data.splice(rowIndex, 1);
            _this.pen.rowPos.splice(rowIndex, 1);
            for (var i = rowIndex; i < _this.pen.rowPos.length; i++) {
                _this.pen.rowPos[i] -= _this.pen.rowHeight;
            }
            _this.pen.calculative.maxOffsetY -=
                _this.pen.rowHeight * _this.pen.calculative.canvas.store.data.scale;
            //有合并单元格情况
            if ((_a = _this.pen.mergeCells) === null || _a === void 0 ? void 0 : _a.length) {
                for (var i = 0; i < _this.pen.mergeCells.length; i++) {
                    var item = _this.pen.mergeCells[i];
                    //合并之间 增加
                    if (item.row <= rowIndex && rowIndex < item.row + item.rowspan) {
                        item.rowspan -= 1;
                    }
                    //合并之前 下移一位
                    if (item.row > rowIndex) {
                        item.row -= 1;
                    }
                    if (item.rowspan < 1 || (item.colspan === 1 && item.rowspan === 1)) {
                        _this.pen.mergeCells.splice(i, 1);
                        i--;
                    }
                }
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.clearRow = function (rowIndex) {
            for (var i = 0; i < _this.pen.colPos.length; i++) {
                _this.pen.data[rowIndex][i] = '';
            }
            _this.pen.calculative.texts = undefined;
            _this.pen.calculative.canvas.render();
        };
        this.clearCells = function () {
            if (_this.pen.calculative.mergeCell) {
                var mergeCell = _this.pen.calculative.mergeCell;
                for (var i = mergeCell.row; i < mergeCell.row + mergeCell.rowspan; i++) {
                    for (var j = mergeCell.col; j < mergeCell.col + mergeCell.colspan; j++) {
                        _this.pen.data[i][j] = '';
                    }
                }
                _this.pen.calculative.texts = undefined;
                _this.pen.calculative.canvas.render();
            }
        };
        this.cancelMerge = function () {
            var _a;
            if ((_a = _this.pen.mergeCells) === null || _a === void 0 ? void 0 : _a.length) {
                for (var i = 0; i < _this.pen.mergeCells.length; i++) {
                    if (cellInCell(_this.pen.mergeCells[i], _this.pen.calculative.mergeCell)) {
                        _this.pen.mergeCells.splice(i, 1);
                        i--;
                    }
                }
                _this.pen.calculative.canvas.render();
            }
            else {
                console.warn('No cells are merged');
            }
        };
        this.mergeCell = function () {
            var _a;
            var mergeCell = _this.pen.calculative.mergeCell;
            if (mergeCell) {
                var cellV = _this.pen.data[mergeCell.row][mergeCell.col];
                _this.clearCells();
                _this.pen.calculative.texts = undefined;
                _this.pen.data[mergeCell.row][mergeCell.col] = cellV;
                if (mergeCell.colspan > 1 || mergeCell.rowspan > 1) {
                    for (var i = 0; i < ((_a = _this.pen.mergeCells) === null || _a === void 0 ? void 0 : _a.length); i++) {
                        if (cellInCell(_this.pen.mergeCells[i], mergeCell)) {
                            _this.pen.mergeCells.splice(i, 1);
                            i--;
                        }
                    }
                    if (!_this.pen.mergeCells) {
                        _this.pen.mergeCells = [];
                    }
                    _this.pen.mergeCells.push(deepClone(mergeCell));
                    _this.pen.calculative.canvas.render();
                }
            }
        };
        this.pen = pen;
        this.options = contextmenu;
        this.init();
    }
    TableContextMenu.prototype.init = function () {
        var _this = this;
        var _a;
        this.menu = document.createElement('ul');
        this.menu.style.position = 'absolute';
        this.menu.style.zIndex = '999';
        this.menu.style.backgroundColor = '#fff';
        this.menu.style.listStyleType = 'none';
        this.menu.style.border = '1px solid #ccc';
        this.menu.style.display = 'none';
        document.body.appendChild(this.menu);
        (_a = this.pen.calculative.canvas.externalElements) === null || _a === void 0 ? void 0 : _a.parentElement.appendChild(this.menu);
        if (!this.pen.calculative.singleton) {
            this.pen.calculative.singleton = {};
        }
        // this.pen.calculative.singleton.contextmenu = this.menu;
        //挂载api
        // this.pen.insertColLeft = this.insertColLeft;
        // this.pen.insertColRight = this.insertColRight;
        // this.pen.deleteCol = this.deleteCol;
        // this.pen.clearCol = this.clearCol;
        // this.pen.insertRowAbove = this.insertRowAbove;
        // this.pen.insertRowBelow = this.insertRowBelow;
        // this.pen.deleteRow = this.deleteRow;
        // this.pen.clearRow = this.clearRow;
        for (var key in this.options) {
            this.options[key].forEach(function (item) {
                _this.pen[item.key] = _this[item.key];
            });
        }
    };
    //更新菜单内容
    TableContextMenu.prototype.updateMenu = function (key, e) {
        if (this.key !== key) {
            this.key = key;
            this.setMenuList();
        }
        this.menu.style.display = 'block';
        this.menu.style.left = e.x + 'px';
        this.menu.style.top = e.y + 'px';
    };
    TableContextMenu.prototype.setMenuList = function () {
        var _this = this;
        //删除原有menu项
        while (this.menu.firstChild) {
            this.menu.removeChild(this.menu.firstChild);
        }
        var _loop_5 = function (i) {
            var li = document.createElement('li');
            li.style.width = '100px';
            li.style.height = '26px';
            li.style.color = '#373737';
            li.style.paddingLeft = '12px';
            li.style.lineHeight = '26px';
            li.style.cursor = 'pointer';
            li.innerText = this_1.options[this_1.key][i].name;
            li.onclick = function () {
                if (['row', 'col'].includes(_this.key)) {
                    _this.pen[_this.options[_this.key][i].key](_this.pen.calculative[_this.key === 'row' ? 'activeRow' : 'activeCol']);
                }
                else {
                    _this.pen[_this.options[_this.key][i].key]();
                }
                _this.menu.style.display = 'none';
            };
            li.onmouseover = function () {
                li.style.backgroundColor = '#f5f5f5';
            };
            li.onmouseleave = function () {
                li.style.backgroundColor = '';
            };
            this_1.menu.appendChild(li);
        };
        var this_1 = this;
        for (var i = 0; i < this.options[this.key].length; i++) {
            _loop_5(i);
        }
    };
    TableContextMenu.prototype.hide = function () {
        this.menu.style.display = 'none';
    };
    TableContextMenu.prototype.destroy = function () {
        this.menu.remove();
    };
    return TableContextMenu;
}());
export { TableContextMenu };
var TableScroll = /** @class */ (function () {
    function TableScroll(pen) {
        var _this = this;
        this.scrollLength = 20;
        this.onMouseMove = function (e) {
            if (_this.isDownH) {
                var y = e.y - _this.isDownH;
                var timesY = _this.pen.calculative.maxOffsetY / _this.pen.calculative.worldRect.height;
                scroll(_this.pen, y * timesY);
                _this.updataScrollHTop();
                _this.isDownH = e.y;
            }
            // e.preventDefault();
            // e.stopPropagation();
        };
        this.onMouseUp = function (e) {
            _this.isDownH = 0;
            _this.isDownW = 0;
        };
        this.pen = pen;
        this.init();
        document.addEventListener('mousemove', this.onMouseMove);
        document.addEventListener('mouseup', this.onMouseUp);
    }
    TableScroll.prototype.init = function () {
        var _this = this;
        var _a, _b;
        this.h = document.createElement('div');
        this.w = document.createElement('div');
        // if(!this.pen.calculative.singleton){
        // this.pen.calculative.singleton = {};
        // }
        // this.pen.calculative.singleton.h = this.h;
        // this.pen.calculative.singleton.w = this.w;
        // pen.calculative.canvas.externalElements
        (_a = this.pen.calculative.canvas.externalElements) === null || _a === void 0 ? void 0 : _a.parentElement.appendChild(this.h);
        (_b = this.pen.calculative.canvas.externalElements) === null || _b === void 0 ? void 0 : _b.parentElement.appendChild(this.w);
        this.h.style.position = 'absolute';
        this.h.style.height = '100px';
        this.h.style.width = '5px';
        // h.style.display = 'block';
        this.h.style.borderRadius = this.scrollLength + "px";
        this.h.style.backgroundColor = 'rgba(0,0,0)';
        this.h.style.zIndex = '999';
        this.h.style.cursor = 'pointer';
        this.h.onmousedown = function (e) {
            e.preventDefault();
            e.stopPropagation();
            _this.isDownH = e.y;
        };
        this.updataScroll();
    };
    TableScroll.prototype.updataScroll = function () {
        if (this.h) {
            this.h.style.left =
                this.pen.calculative.worldRect.x +
                    this.pen.calculative.canvas.store.data.x +
                    this.pen.calculative.worldRect.width -
                    5 +
                    'px';
            this.h.style.height =
                this.scrollLength * this.pen.calculative.canvas.store.data.scale + 'px';
            this.updataScrollHTop();
        }
    };
    TableScroll.prototype.updataScrollHTop = function () {
        if (this.h) {
            var scale = this.pen.calculative.canvas.store.data.scale;
            var timesY = this.pen.calculative.worldRect.height / this.pen.initWorldRect.height;
            this.h.style.top =
                this.pen.calculative.worldRect.y +
                    this.pen.calculative.canvas.store.data.y +
                    (this.pen.offsetY / (this.pen.calculative.maxOffsetY * timesY)) *
                        (this.pen.calculative.worldRect.height -
                            this.scrollLength * this.pen.calculative.canvas.store.data.scale) +
                    'px';
        }
    };
    TableScroll.prototype.hideScroll = function () {
        if (this.h && !this.isDownH) {
            this.h.style.display = 'none';
        }
    };
    TableScroll.prototype.showScroll = function () {
        if (this.h) {
            this.h.style.display = 'block';
        }
    };
    TableScroll.prototype.destroy = function () {
        this.h.remove();
        this.w.remove();
        document.removeEventListener('mousemove', this.onMouseMove);
        document.removeEventListener('mouseup', this.onMouseUp);
    };
    return TableScroll;
}());
export { TableScroll };
//# sourceMappingURL=table3.js.map