import { LineAnimateType } from '../../pen';
//箭头动画
export function drawArrow(pen, ctx) {
    var path = !ctx ? new Path2D() : ctx;
    var worldAnchors = pen.calculative.worldAnchors;
    var scale = pen.calculative.canvas.store.data.scale;
    var size = (pen.calculative.animateLineWidth || 6) * scale; // 箭头大小
    var arrowLength = (pen.animateLineWidth * 2 || 12) * scale; // 箭头长度
    if (pen.lineAnimateType === LineAnimateType.WaterDrop) {
        arrowLength = (pen.animateLineWidth * 4 || 24) * scale; // 水滴长度
    }
    var d = (pen.animateInterval || 100) * scale; // 箭头间距
    var smoothLenth = pen.calculative.lineWidth * (pen.calculative.lineSmooth || 0); //*scale;
    var lineWidth = (pen.calculative.animateLineWidth / 2 || 3) * scale;
    if (pen.animateReverse) {
        //箭头反向
        arrowLength = -arrowLength;
        size = -size;
    }
    if (worldAnchors.length > 1) {
        var from = void 0; // 上一个点
        var lastLength = 0;
        for (var i = 0; i < worldAnchors.length; i++) {
            var pt = worldAnchors[i];
            //获取箭头角度
            if (from) {
                var angle = getAngle(from, pt);
                var newP = {
                    x: from.x +
                        ((pen.calculative.animatePos - lastLength) % d) *
                            Math.cos((angle * Math.PI) / 180),
                    y: from.y -
                        ((pen.calculative.animatePos - lastLength) % d) *
                            Math.sin((angle * Math.PI) / 180),
                };
                if (pen.animateReverse) {
                    newP = {
                        x: from.x +
                            ((pen.length - (pen.calculative.animatePos + lastLength)) % d) *
                                Math.cos((angle * Math.PI) / 180),
                        y: from.y -
                            ((pen.length - (pen.calculative.animatePos + lastLength)) % d) *
                                Math.sin((angle * Math.PI) / 180),
                    };
                }
                var newPTFrom = Math.sqrt(Math.pow((newP.x - from.x), 2) + Math.pow((newP.y - from.y), 2));
                var ptTFrom = Math.sqrt(Math.pow((pt.x - from.x), 2) + Math.pow((pt.y - from.y), 2));
                while (newPTFrom < ptTFrom) {
                    if (((pen.animateReverse && newPTFrom - arrowLength < ptTFrom) || //不允许超出连线绘制
                        (!pen.animateReverse &&
                            newPTFrom > arrowLength)) &&
                        newPTFrom > (smoothLenth + arrowLength) &&
                        ptTFrom - newPTFrom > smoothLenth) {
                        if (pen.lineAnimateType === LineAnimateType.Arrow) {
                            arrow(path, newP, size, angle, lineWidth, arrowLength);
                        }
                        else if (pen.lineAnimateType === LineAnimateType.WaterDrop) {
                            waterDrop(path, newP, pen.animateReverse, angle, lineWidth, arrowLength);
                        }
                    }
                    newP.x += d * Math.cos((angle * Math.PI) / 180);
                    newP.y -= d * Math.sin((angle * Math.PI) / 180);
                    newPTFrom = Math.sqrt(Math.pow((newP.x - from.x), 2) + Math.pow((newP.y - from.y), 2));
                }
                // lastLength += ptTFrom-newPTFrom;
            }
            from = pt;
        }
    }
    if (path instanceof Path2D)
        return path;
}
//获取两点连线和水平线的夹角
function getAngle(p1, p2) {
    var dx = p2.x - p1.x;
    var dy = p2.y - p1.y;
    var angle = (Math.atan(dy / dx) * 180) / Math.PI;
    if (p2.x >= p1.x) {
        angle = -angle;
    }
    else {
        angle = 180 - angle;
    }
    return angle;
}
//获取p相对rp旋转_angle后的点坐标
function getRotatePoint(p, rp, _angle) {
    var angle = ((180 - _angle) * Math.PI) / 180;
    return {
        x: (p.x - rp.x) * Math.cos(angle) - (p.y - rp.y) * Math.sin(angle) + rp.x,
        y: (p.x - rp.x) * Math.sin(angle) + (p.y - rp.y) * Math.cos(angle) + rp.y,
    };
}
//标准箭头
function arrow(path, newP, size, angle, lineWidth, arrowLength) {
    var pr = getRotatePoint({ x: newP.x + size, y: newP.y + 0.57 * size }, { x: newP.x, y: newP.y }, angle);
    var pl = getRotatePoint({ x: newP.x + size, y: newP.y - 0.57 * size }, { x: newP.x, y: newP.y }, angle);
    var pr1 = getRotatePoint({ x: newP.x + size, y: newP.y + lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
    var pr2 = getRotatePoint({ x: newP.x + arrowLength, y: newP.y + lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
    var pl1 = getRotatePoint({ x: newP.x + size, y: newP.y - lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
    var pl2 = getRotatePoint({ x: newP.x + arrowLength, y: newP.y - lineWidth / 2 }, { x: newP.x, y: newP.y }, angle);
    path.moveTo(pr.x, pr.y);
    path.lineTo(newP.x, newP.y);
    path.lineTo(pl.x, pl.y);
    path.lineTo(pl1.x, pl1.y);
    path.lineTo(pl2.x, pl2.y);
    path.lineTo(pr2.x, pr2.y);
    path.lineTo(pr1.x, pr1.y);
    path.lineTo(pr.x, pr.y);
}
//水滴
function waterDrop(path, newP, reverse, angle, lineWidth, arrowLength) {
    var dis = lineWidth / 2;
    if (reverse) {
        dis = -lineWidth / 2;
    }
    var pl1 = getRotatePoint({ x: newP.x, y: newP.y + dis }, { x: newP.x, y: newP.y }, angle);
    var pE = getRotatePoint({ x: newP.x + arrowLength, y: newP.y }, { x: newP.x, y: newP.y }, angle);
    var rAngle = Math.PI / 2;
    if (reverse) {
        rAngle = -Math.PI / 2;
    }
    path.moveTo(newP.x, newP.y);
    path.arc(newP.x, newP.y, lineWidth / 2, -rAngle - angle / 180 * Math.PI, rAngle - angle / 180 * Math.PI, false);
    path.lineTo(pE.x, pE.y);
    path.lineTo(pl1.x, pl1.y);
}
//# sourceMappingURL=arrow.js.map