import {
  getFont
} from "./chunk-GB4GNN46.js";
import "./chunk-7D4SUZUM.js";

// node_modules/@meta2d/le5le-charts/src/normalizedAxis.js
var __assign = function() {
  __assign = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign.apply(this, arguments);
};
var maxDecimal = 15;
function fixedNum(num, decimal) {
  if (decimal === void 0) {
    decimal = maxDecimal;
  }
  var str = "" + num;
  if (str.indexOf(".") >= 0)
    str = Number.parseFloat(str).toFixed(decimal);
  return Number.parseFloat(str);
}
function numberValid(num) {
  return typeof num === "number" && Number.isFinite(num);
}
function scaleCompute(option) {
  option = __assign({ max: null, min: null, splitNumber: 4, symmetrical: false, deviation: false, preferZero: false }, option);
  var magics = [
    10,
    15,
    20,
    25,
    30,
    40,
    50,
    60,
    70,
    80,
    90,
    100,
    150
  ];
  var dataMax = option.max, dataMin = option.min, splitNumber = option.splitNumber, symmetrical = option.symmetrical, deviation = option.deviation, preferZero = option.preferZero;
  if (!numberValid(dataMax) || !numberValid(dataMin) || dataMax < dataMin) {
    return { splitNumber };
  } else if (dataMax === dataMin && dataMax === 0) {
    return {
      max: fixedNum(magics[0] * splitNumber),
      min: dataMin,
      interval: magics[0],
      splitNumber
    };
  } else if (dataMax === dataMin) {
    preferZero = true;
  }
  if (!numberValid(splitNumber) || splitNumber <= 0)
    splitNumber = 4;
  if (preferZero && dataMax * dataMin > 0) {
    if (dataMax < 0)
      dataMax = 0;
    else
      dataMin = 0;
  }
  var tempGap = (dataMax - dataMin) / splitNumber;
  var multiple = Math.floor(Math.log10(tempGap) - 1);
  multiple = Math.pow(10, multiple);
  var tempStep = tempGap / multiple;
  var expectedStep = magics[0] * multiple;
  var storedMagicsIndex = -1;
  var index;
  for (index = 0; index < magics.length; index++) {
    if (magics[index] > tempStep) {
      expectedStep = magics[index] * multiple;
      break;
    }
  }
  var axisMax = dataMax;
  var axisMin = dataMin;
  function countDegree(step) {
    axisMax = parseInt("" + (dataMax / step + 1)) * step;
    axisMin = parseInt("" + (dataMin / step - 1)) * step;
    if (dataMax === 0)
      axisMax = 0;
    if (dataMin === 0)
      axisMin = 0;
    if (symmetrical && axisMax * axisMin < 0) {
      var tm = Math.max(Math.abs(axisMax), Math.abs(axisMin));
      axisMax = tm;
      axisMin = -tm;
    }
  }
  countDegree(expectedStep);
  if (deviation) {
    return {
      max: fixedNum(axisMax),
      min: fixedNum(axisMin),
      interval: fixedNum(expectedStep),
      splitNumber: Math.round((axisMax - axisMin) / expectedStep)
    };
  } else if (!symmetrical || axisMax * axisMin > 0) {
    var tempSplitNumber = void 0;
    out: do {
      tempSplitNumber = Math.round((axisMax - axisMin) / expectedStep);
      if ((index - storedMagicsIndex) * (tempSplitNumber - splitNumber) < 0) {
        while (tempSplitNumber < splitNumber) {
          if (axisMin - dataMin <= axisMax - dataMax && axisMin !== 0 || axisMax === 0) {
            axisMin -= expectedStep;
          } else {
            axisMax += expectedStep;
          }
          tempSplitNumber++;
          if (tempSplitNumber === splitNumber)
            break out;
        }
      }
      if (index >= magics.length - 1 || index <= 0 || tempSplitNumber === splitNumber)
        break;
      storedMagicsIndex = index;
      if (tempSplitNumber > splitNumber)
        expectedStep = magics[++index] * multiple;
      else
        expectedStep = magics[--index] * multiple;
      countDegree(expectedStep);
    } while (tempSplitNumber !== splitNumber);
  }
  axisMax = fixedNum(axisMax);
  axisMin = fixedNum(axisMin);
  var interval = fixedNum((axisMax - axisMin) / splitNumber);
  return {
    max: axisMax,
    min: axisMin,
    interval,
    splitNumber
  };
}

// node_modules/@meta2d/le5le-charts/src/coordinateAxis.js
function coordinateAxis(ctx, pen) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p, _q, _r, _s, _t, _u, _v, _w, _x, _y, _z, _0, _1, _2, _3;
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var w = pen.calculative.worldRect.width;
  var h = pen.calculative.worldRect.height;
  var r = w / 2;
  var scale = pen.calculative.canvas.store.data.scale;
  var series = [];
  if (pen.echarts) {
    for (var i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  var collection_data = [];
  for (var i = 0; i < series.length; i++) {
    collection_data = collection_data.concat(series[i]);
  }
  var initOption = {
    max: Math.max.apply(null, collection_data),
    min: Math.min.apply(null, collection_data),
    splitNumber: 5
  };
  var normalizedOption = scaleCompute(initOption);
  var num = pen.echarts ? pen.echarts.option.xAxis.data.length : pen.xAxisData.length;
  ctx.beginPath();
  ctx.strokeStyle = "#BFBFBF";
  ctx.lineWidth = 6 * scale;
  ctx.lineCap = "butt";
  var dash = (w - 1 * (num + 1)) / num;
  ctx.setLineDash([1, dash]);
  ctx.moveTo(x, y + h + 3 * scale);
  ctx.lineTo(x + w, y + h + 3 * scale);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  ctx.lineWidth = 1 * scale;
  ctx.setLineDash([]);
  ctx.moveTo(x, y + h);
  ctx.lineTo(x + w, y + h);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  ctx.fillStyle = "#BFBFBF";
  ctx.strokeStyle = "#E9E9E9";
  ctx.setLineDash([2, 2]);
  var fontOptions = {
    fontStyle: ((_b = (_a = pen.yAxis) === null || _a === void 0 ? void 0 : _a.axisLabel) === null || _b === void 0 ? void 0 : _b.fontStyle) || pen.fontStyle,
    textDecoration: (_d = (_c = pen.yAxis) === null || _c === void 0 ? void 0 : _c.axisLabel) === null || _d === void 0 ? void 0 : _d.textDecoration,
    fontWeight: ((_f = (_e = pen.yAxis) === null || _e === void 0 ? void 0 : _e.axisLabel) === null || _f === void 0 ? void 0 : _f.fontWeight) || pen.fontWeight,
    fontFamily: ((_h = (_g = pen.yAxis) === null || _g === void 0 ? void 0 : _g.axisLabel) === null || _h === void 0 ? void 0 : _h.fontFamily) || pen.fontFamily,
    fontSize: ((_k = (_j = pen.yAxis) === null || _j === void 0 ? void 0 : _j.axisLabel) === null || _k === void 0 ? void 0 : _k.fontSize) || pen.fontSize,
    lineHeight: ((_m = (_l = pen.yAxis) === null || _l === void 0 ? void 0 : _l.axisLabel) === null || _m === void 0 ? void 0 : _m.lineHeight) || pen.lineHeight
  };
  ctx.fillStyle = ((_p = (_o = pen.yAxis) === null || _o === void 0 ? void 0 : _o.axisLabel) === null || _p === void 0 ? void 0 : _p.fontColor) || pen.color;
  for (var i = 0; i < normalizedOption.splitNumber + 1; i++) {
    var temH = i * h / normalizedOption.splitNumber;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.font = getFont(fontOptions);
    ctx.fillText(normalizedOption.max - i * normalizedOption.interval + "", x - 10 * scale, y + temH);
    ctx.fill();
    if (i < normalizedOption.splitNumber) {
      ctx.beginPath();
      ctx.moveTo(x, y + temH);
      ctx.lineTo(x + w, y + temH);
      ctx.stroke();
    }
  }
  ctx.closePath();
  ctx.beginPath();
  ctx.strokeStyle = "#BFBFBF";
  var xData = pen.echarts ? pen.echarts.option.xAxis.data : pen.xAxisData;
  var xdataX = 0;
  for (var i = 0; i < xData.length; i++) {
    xdataX = x + (1 + dash / 2) + (dash + 1) * i;
    ctx.textAlign = "center";
    ctx.textBaseline = "top";
    var fontOptions_1 = {
      fontStyle: ((_r = (_q = pen.xAxis) === null || _q === void 0 ? void 0 : _q.axisLabel) === null || _r === void 0 ? void 0 : _r.fontStyle) || pen.calculative.fontStyle,
      textDecoration: (_t = (_s = pen.xAxis) === null || _s === void 0 ? void 0 : _s.axisLabel) === null || _t === void 0 ? void 0 : _t.textDecoration,
      fontWeight: ((_v = (_u = pen.xAxis) === null || _u === void 0 ? void 0 : _u.axisLabel) === null || _v === void 0 ? void 0 : _v.fontWeight) || pen.calculative.fontWeight,
      fontFamily: ((_x = (_w = pen.xAxis) === null || _w === void 0 ? void 0 : _w.axisLabel) === null || _x === void 0 ? void 0 : _x.fontFamily) || pen.calculative.fontFamily,
      fontSize: ((_z = (_y = pen.xAxis) === null || _y === void 0 ? void 0 : _y.axisLabel) === null || _z === void 0 ? void 0 : _z.fontSize) || pen.calculative.fontSize,
      lineHeight: ((_1 = (_0 = pen.xAxis) === null || _0 === void 0 ? void 0 : _0.axisLabel) === null || _1 === void 0 ? void 0 : _1.lineHeight) || pen.calculative.lineHeight
    };
    ctx.font = getFont(fontOptions_1);
    ctx.fillStyle = ((_3 = (_2 = pen.xAxis) === null || _2 === void 0 ? void 0 : _2.axisLabel) === null || _3 === void 0 ? void 0 : _3.fontColor) || pen.calculative.color;
    ctx.fillText(xData[i], xdataX, y + h + 10 * scale);
    ctx.fill();
  }
  ctx.closePath();
  ctx.setLineDash([]);
  return { dash, normalizedOption };
}

// node_modules/@meta2d/le5le-charts/src/common.js
function getValidValue(num, value) {
  if (isNaN(num)) {
    return;
  }
  if (value === -1) {
    return num;
  }
  return Math.round(Number(num) * 1e3) / 1e3;
}
var ReplaceMode;
(function(ReplaceMode2) {
  ReplaceMode2[ReplaceMode2["Add"] = 0] = "Add";
  ReplaceMode2[ReplaceMode2["Replace"] = 1] = "Replace";
  ReplaceMode2[ReplaceMode2["ReplaceAll"] = 2] = "ReplaceAll";
})(ReplaceMode || (ReplaceMode = {}));

// node_modules/@meta2d/le5le-charts/src/lineChart.js
var __read = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function lineChart(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = beforeValue;
  }
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var w = pen.calculative.worldRect.width;
  var h = pen.calculative.worldRect.height;
  var scale = pen.calculative.canvas.store.data.scale;
  var series = [];
  if (pen.echarts && !pen.echarts.option.color) {
    pen.echarts.option.color = [
      "#1890ff",
      "#2FC25B",
      "#FACC14",
      "#c23531",
      "#2f4554",
      "#61a0a8",
      "#d48265"
    ];
  }
  var coordinate = coordinateAxis(ctx, pen);
  var dash = coordinate.dash;
  var normalizedOption = coordinate.normalizedOption;
  var smooth = (pen.echarts ? pen.echarts.option.series[0].smooth : pen.smooth) ? true : false;
  var coordinateValue = [];
  if (pen.echarts) {
    for (var i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  var _loop_1 = function(j2) {
    ctx.beginPath();
    var data = series[j2];
    ctx.strokeStyle = pen.echarts ? pen.echarts.option.color[j2] : pen.chartsColor[j2];
    ctx.fillStyle = pen.echarts ? pen.echarts.option.color[j2] : pen.chartsColor[j2];
    var currentX = x + (1 + dash / 2);
    var currentY = y + h - (data[0] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
    ctx.moveTo(currentX, currentY);
    coordinateValue.push({ x: currentX, y: currentY });
    if (smooth) {
      if (data.length <= 2) {
        for (var i2 = 1; i2 < data.length; i2++) {
          currentX = x + (1 + dash / 2) + (dash + 1) * i2;
          currentY = y + h - (data[i2] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          ctx.lineTo(currentX, currentY);
          coordinateValue.push({ x: currentX, y: currentY });
        }
      } else {
        var cAx_1, cAy_1, cBx_1, cBy_1;
        data.forEach(function(item, index) {
          currentX = x + (1 + dash / 2) + (dash + 1) * index;
          currentY = y + h - (data[index] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          var last1x = x + (1 + dash / 2) + (dash + 1) * (index + 1);
          var last1y = y + h - (data[index + 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          var before1x = x + (1 + dash / 2) + (dash + 1) * (index - 1);
          var before1y = y + h - (data[index - 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          var last2x = x + (1 + dash / 2) + (dash + 1) * (index + 2);
          var last2y = y + h - (data[index + 2] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          if (index === 0) {
            before1x = x + (1 + dash / 2) + (dash + 1) * index;
            before1y = y + h - (data[index] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          } else if (index === data.length - 2) {
            last2x = x + (1 + dash / 2) + (dash + 1) * (index + 1);
            last2y = y + h - (data[index + 1] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
          }
          coordinateValue.push({ x: currentX, y: currentY });
          cAx_1 = currentX + (last1x - before1x) / 4;
          cAy_1 = currentY + (last1y - before1y) / 4;
          cBx_1 = last1x - (last2x - currentX) / 4;
          cBy_1 = last1y - (last2y - currentY) / 4;
          ctx.bezierCurveTo(cAx_1, cAy_1, cBx_1, cBy_1, last1x, last1y);
        });
      }
    } else {
      for (var i2 = 1; i2 < data.length; i2++) {
        currentX = x + (1 + dash / 2) + (dash + 1) * i2;
        currentY = y + h - (data[i2] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
        ctx.lineTo(currentX, currentY);
        coordinateValue.push({ x: currentX, y: currentY });
      }
    }
    ctx.stroke();
    ctx.closePath();
    ctx.save();
    coordinateValue.forEach(function(item, index) {
      ctx.beginPath();
      ctx.strokeStyle = "#fff";
      ctx.lineWidth = 2 * scale;
      ctx.arc(item.x, item.y, 4 * scale, 0, Math.PI * 2);
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
    });
    ctx.restore();
    coordinateValue = [];
  };
  for (var j = 0; j < series.length; j++) {
    _loop_1(j);
  }
}
function beforeValue(pen, value) {
  if (value.xAxisData || value.data || !value.dataX && !value.dataY) {
    return value;
  }
  var _xAxisData = pen.xAxisData;
  var _data = pen.data;
  var replaceMode = pen.replaceMode;
  var xAxisData = [];
  var data = [];
  if (!replaceMode) {
    xAxisData = __spreadArray(__spreadArray([], __read(_xAxisData), false), __read(value.dataX), false);
    _data.forEach(function(item, index) {
      var _item = __spreadArray(__spreadArray([], __read(item), false), __read(value.dataY[index]), false);
      data.push(_item);
    });
  } else if (replaceMode === ReplaceMode.Replace) {
    value.dataX.forEach(function(item, i) {
      var _index = _xAxisData.indexOf(item);
      _data.forEach(function(d, index) {
        d[_index] = value.dataY[index][i];
      });
    });
    xAxisData = _xAxisData;
    data = _data;
  } else if (replaceMode === ReplaceMode.ReplaceAll) {
    xAxisData = value.dataX;
    data = value.dataY;
  }
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, { xAxisData, data });
}

// node_modules/@meta2d/le5le-charts/src/pieChart.js
var __read2 = function(o, n) {
  var m = typeof Symbol === "function" && o[Symbol.iterator];
  if (!m) return o;
  var i = m.call(o), r, ar = [], e;
  try {
    while ((n === void 0 || n-- > 0) && !(r = i.next()).done) ar.push(r.value);
  } catch (error) {
    e = { error };
  } finally {
    try {
      if (r && !r.done && (m = i["return"])) m.call(i);
    } finally {
      if (e) throw e.error;
    }
  }
  return ar;
};
var __spreadArray2 = function(to, from, pack) {
  if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {
    if (ar || !(i in from)) {
      if (!ar) ar = Array.prototype.slice.call(from, 0, i);
      ar[i] = from[i];
    }
  }
  return to.concat(ar || Array.prototype.slice.call(from));
};
function pieChart(ctx, pen) {
  var _a, _b;
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = beforeValue2;
  }
  var scale = pen.calculative.canvas.store.data.scale;
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var w = pen.calculative.worldRect.width;
  var h = pen.calculative.worldRect.height;
  var isEcharts = pen.echarts ? true : false;
  if (pen.echarts) {
    if (!pen.echarts.option.color) {
      pen.echarts.option.color = [
        "#1890ff",
        "#2FC25B",
        "#FACC14",
        "#c23531",
        "#2f4554",
        "#61a0a8",
        "#d48265"
      ];
    }
    pen.chartsColor = pen.echarts.option.color;
  } else {
    if (!pen.chartsColor) {
      pen.chartsColor = [
        "#1890ff",
        "#2FC25B",
        "#FACC14",
        "#c23531",
        "#2f4554",
        "#61a0a8",
        "#d48265"
      ];
    }
  }
  var seriesArray = isEcharts ? pen.echarts.option.series : pen.data;
  var beforeSeriesLength = 0;
  var _loop_1 = function(ser2) {
    var series = seriesArray[ser2];
    var r = w / 2;
    if (h < w) {
      r = h / 2;
    }
    var centerX = x + w / 2;
    var centerY = y + h / 2;
    var sum = 0;
    if (isEcharts) {
      sum = series.data.reduce(function(prev, curr) {
        return prev + curr.value;
      }, 0);
    } else {
      sum = series.reduce(function(prev, curr) {
        return prev + curr.value;
      }, 0);
    }
    var fromR = r * parseFloat(isEcharts ? series.radius[0] : pen.chartsRadius[ser2][0]) / 100;
    var toR = r * parseFloat(isEcharts ? series.radius[1] : pen.chartsRadius[ser2][1]) / 100;
    if (fromR > toR) {
      return { value: void 0 };
    }
    var beforeAngle = 0;
    var afterAngle = 0;
    ctx.strokeStyle = isEcharts ? ((_a = series.itemStyle) === null || _a === void 0 ? void 0 : _a.borderColor) || "#fff" : "#fff";
    ctx.lineWidth = (isEcharts ? ((_b = series.itemStyle) === null || _b === void 0 ? void 0 : _b.borderWidth) || 2 : 2) * scale;
    var data = isEcharts ? series.data : series;
    data.forEach(function(item, index) {
      var _a2, _b2, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o;
      afterAngle += Math.PI * 2 * item.value / sum;
      ctx.beginPath();
      var colorLength = beforeSeriesLength + index;
      if (colorLength >= pen.chartsColor.length) {
        colorLength = colorLength % pen.chartsColor.length;
      }
      ctx.fillStyle = isEcharts ? pen.echarts.option.color[colorLength] : pen.chartsColor[colorLength];
      ctx.moveTo(centerX + fromR * Math.sin(afterAngle), centerY - fromR * Math.cos(afterAngle));
      ctx.arc(centerX, centerY, fromR, -Math.PI / 2 + afterAngle, -Math.PI / 2 + beforeAngle, true);
      ctx.lineTo(centerX + toR * Math.sin(beforeAngle), centerY - toR * Math.cos(beforeAngle));
      ctx.arc(centerX, centerY, toR, -Math.PI / 2 + beforeAngle, -Math.PI / 2 + afterAngle);
      ctx.lineTo(centerX + fromR * Math.sin(afterAngle), centerY - fromR * Math.cos(afterAngle));
      ctx.stroke();
      ctx.fill();
      ctx.closePath();
      var centerAngle = (beforeAngle + afterAngle) / 2;
      var temX = centerX + (toR + 10 * scale) * Math.sin(centerAngle);
      var temY = centerY - (toR + 10 * scale) * Math.cos(centerAngle);
      var temFillStyle = ctx.fillStyle;
      if (!series.label) {
        series.label = { position: "outside", show: true };
      }
      if (isEcharts && ["inner", "inside"].includes(series.label.position)) {
        ctx.fillStyle = "#ffffff";
        temX = centerX + (toR - fromR) / 2 * Math.sin(centerAngle);
        temY = centerY - (toR - fromR) / 2 * Math.cos(centerAngle);
      } else if (isEcharts && series.label.position == "outside") {
      }
      if (!series.labelLine) {
        series.labelLine = { show: true };
      }
      if (isEcharts && series.labelLine.show !== false || !isEcharts) {
        ctx.beginPath();
        ctx.strokeStyle = isEcharts ? pen.echarts.option.color[beforeSeriesLength + index] : pen.chartsColor[beforeSeriesLength + index];
        ctx.moveTo(centerX + toR * Math.sin(centerAngle), centerY - toR * Math.cos(centerAngle));
        ctx.lineTo(temX, temY);
      }
      var fontOption = {
        fontStyle: ((_a2 = pen.tickLabel) === null || _a2 === void 0 ? void 0 : _a2.fontStyle) || pen.calculative.fontStyle,
        fontWeight: ((_b2 = pen.tickLabel) === null || _b2 === void 0 ? void 0 : _b2.fontWeight) || pen.calculative.fontWeight,
        fontFamily: ((_c = pen.tickLabel) === null || _c === void 0 ? void 0 : _c.fontFamily) || pen.calculative.fontFamily,
        lineHeight: ((_d = pen.tickLabel) === null || _d === void 0 ? void 0 : _d.lineHeight) || pen.calculative.lineHeight,
        fontSize: (((_e = pen.tickLabel) === null || _e === void 0 ? void 0 : _e.fontSize) || pen.calculative.fontSize) * scale
      };
      ctx.font = getFont(fontOption);
      ctx.textBaseline = "middle";
      ctx.textAlign = "center";
      if (centerAngle > Math.PI) {
        if (isEcharts && series.label.position === "outside" || !isEcharts) {
          ctx.textAlign = "end";
        }
        if (isEcharts && series.labelLine.show !== false || !isEcharts && ((_h = (_g = (_f = pen.tickLabel) === null || _f === void 0 ? void 0 : _f.labelLine) === null || _g === void 0 ? void 0 : _g.show) !== null && _h !== void 0 ? _h : true)) {
          ctx.lineTo(temX - 5 * scale, temY);
        }
        if (isEcharts && series.label.show !== false || !isEcharts && ((_k = (_j = pen.tickLabel) === null || _j === void 0 ? void 0 : _j.show) !== null && _k !== void 0 ? _k : true)) {
          ctx.fillText(item.name, temX - 5 * scale, temY);
        }
      } else {
        if (isEcharts && series.label.position === "outside" || !isEcharts) {
          ctx.textAlign = "start";
        }
        if (isEcharts && series.labelLine.show !== false || !isEcharts) {
          ctx.lineTo(temX + 5 * scale, temY);
        }
        if (isEcharts && series.label.show !== false || !isEcharts && ((_m = (_l = pen.tickLabel) === null || _l === void 0 ? void 0 : _l.show) !== null && _m !== void 0 ? _m : true)) {
          ctx.fillText(item.name, temX + 5 * scale, temY);
        }
      }
      ctx.stroke();
      ctx.closePath();
      ctx.fillStyle = temFillStyle;
      ctx.strokeStyle = isEcharts ? ((_o = series.itemStyle) === null || _o === void 0 ? void 0 : _o.borderColor) || "#fff" : "#fff";
      beforeAngle = afterAngle;
    });
    beforeSeriesLength += data.length;
  };
  for (var ser = 0; ser < seriesArray.length; ser++) {
    var state_1 = _loop_1(ser);
    if (typeof state_1 === "object")
      return state_1.value;
  }
}
function beforeValue2(pen, value) {
  if (value.data || !value.dataX && !value.dataY) {
    return value;
  }
  var _data = pen.data;
  var replaceMode = pen.replaceMode;
  var data = [];
  if (!replaceMode) {
    _data.forEach(function(item, index) {
      var _item = __spreadArray2(__spreadArray2([], __read2(item), false), __read2(value.dataY[index]), false);
      data.push(_item);
    });
  } else if (replaceMode === ReplaceMode.Replace) {
    value.dataY.forEach(function(item, index) {
      item.forEach(function(_innerItem, _innderIndex) {
        var _filterItem = _data[index].filter(function(_i) {
          return _i.name === _innerItem.name;
        });
        if (_filterItem.length > 0) {
          _filterItem[0].value = _innerItem.value;
        }
      });
    });
    data = _data;
  } else if (replaceMode === ReplaceMode.ReplaceAll) {
    data = value.dataY;
  }
  delete value.dataX;
  delete value.dataY;
  return Object.assign(value, { data });
}

// node_modules/@meta2d/le5le-charts/src/histogram.js
function histogram(ctx, pen) {
  if (!pen.onBeforeValue) {
    pen.onBeforeValue = beforeValue;
  }
  var scale = pen.calculative.canvas.store.data.scale;
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var w = pen.calculative.worldRect.width;
  var h = pen.calculative.worldRect.height;
  var series = [];
  if (pen.echarts && !pen.echarts.option.color) {
    pen.echarts.option.color = [
      "#1890ff",
      "#2FC25B",
      "#FACC14",
      "#c23531",
      "#2f4554",
      "#61a0a8",
      "#d48265"
    ];
  }
  if (pen.echarts) {
    for (var i = 0; i < pen.echarts.option.series.length; i++) {
      series.push(pen.echarts.option.series[i].data);
    }
  } else {
    series = pen.data;
  }
  var coordinate = coordinateAxis(ctx, pen);
  var dash = coordinate.dash;
  var normalizedOption = coordinate.normalizedOption;
  var itemWidth = dash * 4 / 5 / series.length;
  for (var j = 0; j < series.length; j++) {
    ctx.beginPath();
    var data = series[j];
    ctx.fillStyle = pen.echarts ? pen.echarts.option.color[j] : pen.chartsColor[j];
    ctx.strokeStyle = "#ffffff";
    ctx.lineWidth = 1 * scale;
    var currentX = 0;
    var currentY = 0;
    var currentH = 0;
    for (var i = 0; i < data.length; i++) {
      currentX = x + (1 + 0.1 * dash) + (dash + 1) * i + itemWidth * j;
      currentH = (data[i] - normalizedOption.min) / (normalizedOption.max - normalizedOption.min) * h;
      currentY = y + h - currentH;
      ctx.rect(currentX, currentY, itemWidth - 1, currentH - 1);
      ctx.stroke();
      ctx.fill();
    }
    ctx.closePath();
  }
}

// node_modules/@meta2d/le5le-charts/src/gauge.js
var __assign2 = function() {
  __assign2 = Object.assign || function(t) {
    for (var s, i = 1, n = arguments.length; i < n; i++) {
      s = arguments[i];
      for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p))
        t[p] = s[p];
    }
    return t;
  };
  return __assign2.apply(this, arguments);
};
function gauge(ctx, pen) {
  var _a, _b, _c, _d, _e, _f, _g, _h, _j, _k, _l, _m, _o, _p;
  if (!pen.onAdd) {
    pen.onAdd = onAdd;
    pen.onDestroy = onDestroy;
    pen.onClick = onclick;
    if (pen.clockInterval) {
      pen.onDestroy(pen);
      pen.onAdd(pen);
    }
  }
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var w = pen.calculative.worldRect.width;
  var h = pen.calculative.worldRect.height;
  var scale = pen.calculative.canvas.store.data.scale;
  var basicConfigure = {
    startAngle: 225,
    endAngle: -45,
    min: 0,
    max: 100,
    splitNumber: 10
  };
  if (pen.echarts && pen.echarts.option) {
    var series = pen.echarts.option.series[0];
    pen.startAngle = series.startAngle || basicConfigure.startAngle;
    pen.endAngle = series.endAngle || basicConfigure.endAngle;
    pen.min = series.min || basicConfigure.min;
    pen.max = series.max || basicConfigure.max;
    pen.axisLine = series.axisLine.lineStyle.color;
    pen.unit = series.detail.formatter.replace("{value}", "");
    pen.value = series.data[0].value;
    pen.splitNumber = series.splitNumber || basicConfigure.splitNumber;
  }
  pen = __assign2(__assign2({}, basicConfigure), pen);
  var r = w > h ? h / 2 * 9 / 10 : w / 2 * 9 / 10;
  var centerX = x + w / 2;
  var centerY = y + h / 2;
  var value = pen.echarts ? pen.echarts.option.series[0].data[0].value : pen.value;
  var pointColor;
  var gap = pen.startAngle - pen.endAngle;
  var bgColor = pen.background || "#E6EBF8";
  ctx.strokeStyle = bgColor;
  var bgLineWidth = r / 10;
  ctx.lineWidth = bgLineWidth;
  ctx.beginPath();
  ctx.lineCap = "round";
  ctx.arc(centerX, centerY, r, -pen.startAngle / 180 * Math.PI, -pen.endAngle / 180 * Math.PI);
  ctx.stroke();
  ctx.closePath();
  var bili = 0;
  if (pen.axisLine && !pen.isClock) {
    for (var i = pen.axisLine.length - 1; i >= 0; i--) {
      if (pen.axisLine[i][0] * (pen.max - pen.min) < value) {
        bili = pen.axisLine[i][0];
      } else {
        bili = (value - pen.min) / (pen.max - pen.min);
        pointColor = pen.axisLine[i][1];
      }
      ctx.beginPath();
      ctx.strokeStyle = pen.axisLine[i][1];
      ctx.arc(centerX, centerY, r, -pen.startAngle / 180 * Math.PI, (-pen.startAngle + bili * gap) / 180 * Math.PI);
      ctx.stroke();
      ctx.closePath();
    }
  }
  ctx.lineCap = "butt";
  var dashWidth = 2 * scale;
  var mainR = r - bgLineWidth;
  if (mainR < 0) {
    mainR = 0;
  }
  var arcLength = gap / 180 * Math.PI * mainR;
  var dash = (arcLength - dashWidth * pen.splitNumber) / pen.splitNumber;
  var offsetAngle = gap / 180 * Math.PI * dashWidth / 2 / arcLength;
  ctx.beginPath();
  ctx.strokeStyle = pen.color || "#999999";
  ctx.lineWidth = r / 20;
  ctx.setLineDash([dashWidth, dash]);
  ctx.arc(centerX, centerY, mainR, -pen.startAngle / 180 * Math.PI - offsetAngle, -pen.endAngle / 180 * Math.PI + offsetAngle);
  ctx.stroke();
  ctx.closePath();
  var fromDashWidth = 1 * scale;
  var fromR = r - bgLineWidth;
  if (fromR < 0) {
    fromR = 0;
  }
  var fromArcLength = gap / 180 * Math.PI * fromR;
  var fromDash = (fromArcLength - fromDashWidth * 5 * pen.splitNumber) / 5 / pen.splitNumber;
  var fromOffsetAngle = gap / 180 * Math.PI * fromDashWidth / 2 / fromArcLength;
  ctx.beginPath();
  ctx.strokeStyle = pen.color || "#999999";
  ctx.lineWidth = r / 40;
  ctx.setLineDash([fromDashWidth, fromDash]);
  ctx.arc(centerX, centerY, fromR, -pen.startAngle / 180 * Math.PI - fromOffsetAngle, -pen.endAngle / 180 * Math.PI + fromOffsetAngle);
  ctx.stroke();
  ctx.closePath();
  ctx.beginPath();
  var valueGap = pen.max - pen.min;
  var interval = valueGap / pen.splitNumber;
  var fontOption = {
    fontStyle: ((_a = pen.tickLabel) === null || _a === void 0 ? void 0 : _a.fontStyle) || pen.calculative.fontStyle,
    textDecoration: ((_b = pen.tickLabel) === null || _b === void 0 ? void 0 : _b.textDecoration) || pen.textDecoration,
    fontWeight: ((_c = pen.tickLabel) === null || _c === void 0 ? void 0 : _c.fontWeight) || pen.calculative.fontWeight,
    fontFamily: ((_d = pen.tickLabel) === null || _d === void 0 ? void 0 : _d.fontFamily) || pen.calculative.fontFamily,
    fontSize: (((_e = pen.tickLabel) === null || _e === void 0 ? void 0 : _e.fontSize) || pen.calculative.fontSize) * scale,
    lineHeight: ((_f = pen.tickLabel) === null || _f === void 0 ? void 0 : _f.lineHeight) || pen.calculative.lineHeight
  };
  ctx.font = getFont(fontOption);
  var textR = r - bgLineWidth - r / 20;
  for (var i = 0; i <= pen.splitNumber; i++) {
    if (Math.abs(pen.startAngle) + Math.abs(pen.endAngle) === 360) {
      if (i == 0)
        continue;
    }
    var angle = pen.startAngle - interval * i / valueGap * gap;
    var width = Math.cos(angle / 180 * Math.PI);
    var height = Math.sin(angle / 180 * Math.PI);
    ctx.fillStyle = ((_g = pen.tickLabel) === null || _g === void 0 ? void 0 : _g.color) || "#999999";
    if (width > 0.02) {
      ctx.textAlign = "end";
    } else if (width < -0.02) {
      ctx.textAlign = "start";
    } else {
      ctx.textAlign = "center";
    }
    if (height > 0.02) {
      ctx.textBaseline = "top";
    } else if (height < -0.02) {
      ctx.textBaseline = "bottom";
    } else {
      ctx.textBaseline = "middle";
    }
    ctx.fillText(getValidValue(interval * i + pen.min, 1), centerX + textR * width, centerY - textR * height);
    ctx.fill();
  }
  ctx.closePath();
  var pointNum = 1;
  var valueArray = ["value"];
  if (pen.isClock) {
    pointNum = 3;
    valueArray = ["hourvalue", "minutevalue", "secondvalue"];
  }
  if (pen.isClock) {
    for (var i = 0; i < pointNum; i++) {
      var currentAngle = (pen.startAngle - (pen[valueArray[i]] - pen.min) / (pen.max - pen.min) * gap) / 180 * Math.PI;
      if (i > 0) {
        currentAngle = (pen.startAngle - (pen[valueArray[i]] - pen.min) / (pen.max * 5 - pen.min) * gap) / 180 * Math.PI;
      }
      var pointerR = 4 / 5 * r;
      if (valueArray[i] === "hourvalue") {
        pointerR = 3 / 5 * r;
      }
      if (valueArray[i] === "minutevalue") {
        pointerR = 3.5 / 5 * r;
      }
      var pointerHalfW = r * 1 / 40;
      ctx.beginPath();
      ctx.setLineDash([]);
      ctx.lineWidth = r / (i + 1) / 20;
      ctx.strokeStyle = pen.color || "#999999";
      ctx.moveTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
      ctx.lineTo(centerX + pointerR * Math.cos(currentAngle), centerY - pointerR * Math.sin(currentAngle));
      ctx.stroke();
    }
  } else {
    var currentAngle = (pen.startAngle - (value - pen.min) / (pen.max - pen.min) * gap) / 180 * Math.PI;
    var pointerR = 4 / 5 * r;
    var pointerHalfW = r * 1 / 40;
    ctx.beginPath();
    ctx.setLineDash([]);
    ctx.lineWidth = 2;
    ctx.fillStyle = pointColor;
    ctx.moveTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
    ctx.lineTo(centerX + pointerHalfW * Math.cos(currentAngle - Math.PI / 2), centerY - pointerHalfW * Math.sin(currentAngle - Math.PI / 2));
    ctx.lineTo(centerX + pointerR * Math.cos(currentAngle), centerY - pointerR * Math.sin(currentAngle));
    ctx.lineTo(centerX + pointerHalfW * Math.cos(currentAngle + Math.PI / 2), centerY - pointerHalfW * Math.sin(currentAngle + Math.PI / 2));
    ctx.lineTo(centerX - pointerHalfW * 3 * Math.cos(currentAngle), centerY + pointerHalfW * 3 * Math.sin(currentAngle));
    ctx.fill();
  }
  ctx.beginPath();
  ctx.textAlign = "center";
  ctx.textBaseline = "middle";
  var titleOption = {
    fontStyle: ((_h = pen.titleLabel) === null || _h === void 0 ? void 0 : _h.fontStyle) || pen.calculative.fontStyle,
    textDecoration: ((_j = pen.titleLabel) === null || _j === void 0 ? void 0 : _j.textDecoration) || pen.textDecoration,
    fontWeight: ((_k = pen.titleLabel) === null || _k === void 0 ? void 0 : _k.fontWeight) || pen.calculative.fontWeight,
    fontFamily: ((_l = pen.titleLabel) === null || _l === void 0 ? void 0 : _l.fontFamily) || pen.calculative.fontFamily,
    fontSize: (((_m = pen.titleLabel) === null || _m === void 0 ? void 0 : _m.fontSize) || pen.calculative.fontSize) * scale,
    lineHeight: ((_o = pen.titleLabel) === null || _o === void 0 ? void 0 : _o.lineHeight) || pen.calculative.lineHeight
  };
  ctx.font = getFont(titleOption);
  ctx.fillStyle = ((_p = pen.titleLabel) === null || _p === void 0 ? void 0 : _p.color) || pointColor;
  if (pen.isClock) {
    ctx.fillText(("0" + parseInt(pen.hourvalue)).slice(-2) + ":" + ("0" + parseInt(pen.minutevalue)).slice(-2) + ":" + ("0" + parseInt(pen.secondvalue)).slice(-2), centerX, centerY + r / 2);
  } else {
    ctx.fillText(value + " " + (pen.unit || ""), centerX, centerY + r / 2);
  }
  ctx.fill();
  if (pen.isClock) {
    ctx.beginPath();
    ctx.fillStyle = pen.color || "#999999";
    ctx.strokeStyle = "#ffffff";
    ctx.arc(centerX, centerY, r / 20, 0, Math.PI * 2);
    ctx.stroke();
    ctx.fill();
    ctx.closePath();
  }
}
function onAdd(pen) {
  if (pen.isClock) {
    pen.clockInterval = setInterval(function() {
      var date = /* @__PURE__ */ new Date();
      var second = date.getSeconds();
      var minute = date.getMinutes() + second / 60;
      var hour = date.getHours() % 12 + minute / 60;
      pen.calculative.canvas.parent.setValue({
        id: pen.id,
        hourvalue: hour,
        minutevalue: minute,
        secondvalue: second
      }, {
        render: true,
        doEvent: false
      });
    }, 1e3);
  } else {
    var tem_1 = pen.value;
    pen.value = 0;
    pen.frames = [
      {
        duration: 2e3,
        value: tem_1
      }
    ];
    pen.calculative.canvas.parent.startAnimate(pen.id);
    setTimeout(function() {
      pen.value = tem_1;
    }, 1e3);
  }
}
function onDestroy(pen) {
  if (pen.clockInterval) {
    clearInterval(pen.clockInterval);
    pen.clockInterval = void 0;
  }
}
function onclick(pen) {
  if (pen.isClock) {
    pen.onDestroy(pen);
    pen.onAdd(pen);
  }
}

// node_modules/@meta2d/le5le-charts/src/register.js
function chartsPens() {
  return {
    lineChart,
    histogram,
    pieChart,
    gauge
  };
}
export {
  beforeValue,
  chartsPens,
  gauge,
  histogram,
  lineChart,
  pieChart
};
//# sourceMappingURL=@meta2d_le5le-charts.js.map
