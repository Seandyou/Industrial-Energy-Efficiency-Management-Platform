import {
  calcRightBottom,
  calcTextLines,
  calcTextRect,
  deepClone,
  getFont,
  getTextColor,
  pSBC
} from "./chunk-GB4GNN46.js";
import "./chunk-7D4SUZUM.js";

// node_modules/@meta2d/form-diagram/src/table.js
var __values = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function table(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = onAdd;
    pen.onMouseMove = onMouseMove;
    pen.onMouseLeave = onMouseLeave;
    pen.onMouseDown = onMouseDown;
    pen.onShowInput = onShowInput;
    pen.onInput = onInput;
    pen.onValue = onValue;
    pen.onBeforeValue = beforeValue;
  }
  var data = pen.calculative.canvas.store.data;
  var options = pen.calculative.canvas.store.options;
  pen.color = pen.color || data.color || options.color;
  pen.activeColor = pen.activeColor || options.activeColor;
  pen.hoverColor = pen.hoverColor || options.hoverColor;
  pen.activeBackground = pen.activeBackground || options.activeBackground;
  pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
  drawGridLine(ctx, pen);
  drawCell(ctx, pen);
}
function initRect(pen) {
  var e_1, _a, e_2, _b;
  var colPos = [];
  var rowPos = [];
  if (!pen.table.rowHeight) {
    pen.table.rowHeight = 40;
  }
  if (!pen.table.colWidth) {
    pen.table.colWidth = 150;
  }
  var width = 0;
  try {
    for (var _c = __values(pen.table.header.data), _d = _c.next(); !_d.done; _d = _c.next()) {
      var item = _d.value;
      width += item.width || pen.table.colWidth;
      colPos.push(width);
    }
  } catch (e_1_1) {
    e_1 = { error: e_1_1 };
  } finally {
    try {
      if (_d && !_d.done && (_a = _c.return)) _a.call(_c);
    } finally {
      if (e_1) throw e_1.error;
    }
  }
  var height = 0;
  if (pen.table.header.show != false) {
    height += pen.table.header.height || pen.table.rowHeight;
    rowPos.push(height);
  }
  try {
    for (var _e = __values(pen.table.data), _f = _e.next(); !_f.done; _f = _e.next()) {
      var item = _f.value;
      height += item.height || pen.table.rowHeight;
      rowPos.push(height);
    }
  } catch (e_2_1) {
    e_2 = { error: e_2_1 };
  } finally {
    try {
      if (_f && !_f.done && (_b = _e.return)) _b.call(_e);
    } finally {
      if (e_2) throw e_2.error;
    }
  }
  pen.colPos = colPos;
  pen.rowPos = rowPos;
  pen.tableWidth = width;
  pen.tableHeight = height;
  if (!pen.width) {
    pen.width = width;
    pen.height = height;
    pen.calculative.width = width;
    pen.calculative.height = height;
    pen.calculative.worldRect = {
      x: pen.x,
      y: pen.y,
      height: pen.height,
      width: pen.width
    };
    calcRightBottom(pen.calculative.worldRect);
  }
}
function drawGridLine(ctx, pen) {
  var e_3, _a;
  if (!pen.colPos) {
    return;
  }
  var worldRect = pen.calculative.worldRect;
  ctx.save();
  ctx.strokeStyle = pen.color;
  ctx.beginPath();
  ctx.rect(worldRect.x, worldRect.y, worldRect.width, worldRect.height);
  if (pen.background) {
    ctx.fillStyle = pen.background;
    ctx.fill();
  }
  ctx.stroke();
  var last = pen.rowPos[pen.rowPos.length - 1];
  try {
    for (var _b = __values(pen.rowPos), _c = _b.next(); !_c.done; _c = _b.next()) {
      var item = _c.value;
      if (item === last) {
        continue;
      }
      var y = item * pen.calculative.worldRect.height / pen.tableHeight;
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y);
      ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y);
      ctx.stroke();
    }
  } catch (e_3_1) {
    e_3 = { error: e_3_1 };
  } finally {
    try {
      if (_c && !_c.done && (_a = _b.return)) _a.call(_b);
    } finally {
      if (e_3) throw e_3.error;
    }
  }
  last = pen.colPos[pen.colPos.length - 1];
  pen.colPos.forEach(function(item2, i) {
    if (item2 === last) {
      return;
    }
    var x = item2 * pen.calculative.worldRect.width / pen.tableWidth;
    ctx.beginPath();
    ctx.moveTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.y);
    ctx.lineTo(pen.calculative.worldRect.x + x, pen.calculative.worldRect.ey);
    ctx.stroke();
  });
  ctx.restore();
}
function drawCell(ctx, pen) {
  var _a, _b, _c, _d;
  if (!pen.colPos) {
    return;
  }
  if (!pen.calculative.texts) {
    pen.calculative.texts = [];
  }
  var textScale = 1;
  for (var i = 0; i < pen.rowPos.length; i++) {
    var _loop_1 = function(j2) {
      var cell = getCell(pen, i, j2);
      var color = cell.color || pen.color;
      var background = cell.background;
      var activeColor = void 0;
      if (((_a = pen.calculative.activeCell) === null || _a === void 0 ? void 0 : _a.row) === i && ((_b = pen.calculative.activeCell) === null || _b === void 0 ? void 0 : _b.col) === j2) {
        color = pen.activeColor;
        background = pen.activeBackground;
        activeColor = color;
      }
      if (((_c = pen.calculative.hoverCell) === null || _c === void 0 ? void 0 : _c.row) === i && ((_d = pen.calculative.hoverCell) === null || _d === void 0 ? void 0 : _d.col) === j2) {
        color = pen.hoverColor;
        background = pen.hoverBackground;
        activeColor = color;
      }
      var rect = getCellRect(pen, i, j2);
      if (background) {
        ctx.save();
        ctx.fillStyle = background;
        ctx.fillRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      if (activeColor) {
        ctx.save();
        ctx.strokeStyle = activeColor;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      pen.calculative.worldTextRect = rect;
      var rowText = pen.calculative.texts[i];
      if (!pen.calculative.texts[i]) {
        rowText = [];
        pen.calculative.texts.push(rowText);
      }
      if (rowText[j2] == null) {
        if (Array.isArray(cell)) {
          rowText[j2] = "";
          if (!cell[0].id) {
            calcChildrenRect(pen, rect, cell);
            pen.calculative.canvas.parent.pushChildren(pen, cell);
          }
          return "continue";
        } else {
          rowText[j2] = cell.text || cell + "";
        }
        if (!rowText[j2]) {
          return "continue";
        }
        rowText[j2] = calcTextLines(pen, rowText[j2]);
      }
      if (!rowText[j2]) {
        return "continue";
      }
      ctx.save();
      ctx.fillStyle = color;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = (pen.calculative.fontStyle || "") + " normal " + (pen.calculative.fontWeight || "") + " " + (pen.calculative.fontSize || 12) * textScale + "px " + pen.calculative.fontFamily;
      if (rowText[j2].length === 1) {
        ctx.fillText(rowText[j2][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
      } else {
        var y_1 = 0.55;
        var lineHeight_1 = pen.calculative.fontSize * pen.calculative.lineHeight * textScale;
        var h = rowText[j2].length * lineHeight_1;
        var top_1 = (rect.height - h) / 2;
        rowText[j2].forEach(function(text, i2) {
          ctx.fillText(text, rect.x + rect.width / 2, rect.y + top_1 + (i2 + y_1) * lineHeight_1);
        });
      }
      ctx.restore();
    };
    for (var j = 0; j < pen.colPos.length; j++) {
      _loop_1(j);
    }
  }
}
function onAdd(pen) {
  initRect(pen);
}
function onShowInput(pen, e) {
  if (!pen.calculative.hoverCell) {
    return;
  }
  var cell = getCell(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  if (Array.isArray(cell)) {
    return;
  }
  pen.calculative.inputCell = pen.calculative.hoverCell;
  var rect = getCellRect(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  pen.calculative.tempText = cell.text || cell + "";
  pen.calculative.canvas.showInput(pen, rect, "#ffffff");
}
function onInput(pen, text) {
  if (!pen.calculative.inputCell) {
    return;
  }
  setCellText(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
  pen.calculative.canvas.render();
}
function onMouseMove(pen, e) {
  pen.calculative.hoverCell = getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
function onMouseLeave(pen, e) {
  pen.calculative.hoverCell = void 0;
  pen.calculative.canvas.render();
}
function onMouseDown(pen, e) {
  pen.calculative.activeCell = getCellIndex(pen, e);
  pen.calculative.canvas.render();
}
function getCellIndex(pen, e) {
  var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var pos = { row: 0, col: 0 };
  for (var i = 0; i < pen.colPos.length; i++) {
    if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
      pos.col = i + 1;
    }
  }
  for (var i = 0; i < pen.rowPos.length; i++) {
    if (e.y > pen.calculative.worldRect.y + pen.rowPos[i] * scaleY) {
      pos.row = i + 1;
    }
  }
  return pos;
}
function getCell(pen, rowIndex, colIndex) {
  if (!pen.table.data || !Array.isArray(pen.table.data)) {
    return;
  }
  if (pen.table.header.show == false) {
    var row_1 = pen.table.data[rowIndex];
    if (Array.isArray(row_1)) {
      return row_1[colIndex];
    } else if (!row_1.data || !Array.isArray(row_1.data)) {
      return;
    }
    return row_1.data[colIndex];
  }
  if (rowIndex === 0) {
    var cell = pen.table.header.data[colIndex];
    cell.fontWeight = pen.table.header.fontWeight;
    return cell;
  }
  var row = pen.table.data[rowIndex - 1];
  if (!row) {
    return;
  } else if (Array.isArray(row)) {
    return row[colIndex];
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
  return row.data[colIndex];
}
function setCellText(pen, rowIndex, colIndex, text) {
  if (!pen.table.data || !Array.isArray(pen.table.data)) {
    return;
  }
  pen.calculative.texts = void 0;
  var rowData;
  if (pen.table.header.show == false) {
    rowData = pen.table.data[rowIndex];
    if (Array.isArray(rowData)) {
    } else if (rowData.data && Array.isArray(rowData.data)) {
      rowData = rowData.data;
    }
  } else {
    if (rowIndex === 0) {
      rowData = pen.table.header.data;
    } else {
      rowData = pen.table.data[rowIndex - 1];
      if (Array.isArray(rowData)) {
      } else if (rowData.data && Array.isArray(rowData.data)) {
        rowData = rowData.data;
      }
    }
  }
  if (!rowData) {
    return;
  }
  if (rowData[colIndex] instanceof Object) {
    rowData[colIndex].text = text;
  } else {
    rowData[colIndex] = text;
  }
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
}
function getCellRect(pen, rowIndex, colIndex) {
  var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var x = 0;
  var ex = pen.colPos[colIndex] * scaleX;
  if (colIndex > 0) {
    x = pen.colPos[colIndex - 1] * scaleX;
  }
  var y = 0;
  var ey = pen.rowPos[rowIndex] * scaleY;
  if (rowIndex > 0) {
    y = pen.rowPos[rowIndex - 1] * scaleY;
  }
  return {
    x: pen.calculative.worldRect.x + x,
    y: pen.calculative.worldRect.y + y,
    ex: pen.calculative.worldRect.x + ex,
    ey: pen.calculative.worldRect.y + ey,
    width: ex - x,
    height: ey - y
  };
}
function calcChildrenRect(pen, rect, children) {
  var e_4, _a, e_5, _b;
  var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var height = 0;
  var lastX = 0;
  var lastY = 0;
  try {
    for (var children_1 = __values(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
      var item = children_1_1.value;
      if (lastX + item.width * scaleX + 20 * scaleX < rect.width) {
        item.x = rect.x + lastX + 10 * scaleX;
        item.y = rect.y + lastY + 10 * scaleY;
        lastX += (item.width + 10) * scaleX;
        height = Math.max(height, lastY + (item.height + 10) * scaleY);
      } else {
        lastX = 0;
        lastY = height;
        item.x = rect.x + lastX + 10 * scaleX;
        item.y = rect.y + lastY + 10 * scaleY;
        height += (item.height + 10) * scaleY;
      }
    }
  } catch (e_4_1) {
    e_4 = { error: e_4_1 };
  } finally {
    try {
      if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
    } finally {
      if (e_4) throw e_4.error;
    }
  }
  if (height + 20 * scaleY < rect.height) {
    var top_2 = (rect.height - height - 10 * scaleY) / 2;
    try {
      for (var children_2 = __values(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
        var item = children_2_1.value;
        item.y += top_2;
      }
    } catch (e_5_1) {
      e_5 = { error: e_5_1 };
    } finally {
      try {
        if (children_2_1 && !children_2_1.done && (_b = children_2.return)) _b.call(children_2);
      } finally {
        if (e_5) throw e_5.error;
      }
    }
  }
}
function onValue(pen) {
  pen.calculative.texts = void 0;
}
function beforeValue(pen, value) {
  if (value.table || value.col == void 0 && value.row == void 0) {
    return value;
  }
  setCellText(pen, value.row, value.col, value.value);
  pen.calculative.canvas.render();
  delete value.col;
  delete value.row;
  return value;
}

// node_modules/@meta2d/form-diagram/src/common.js
var ReplaceMode;
(function(ReplaceMode2) {
  ReplaceMode2[ReplaceMode2["Add"] = 0] = "Add";
  ReplaceMode2[ReplaceMode2["Replace"] = 1] = "Replace";
  ReplaceMode2[ReplaceMode2["ReplaceAll"] = 2] = "ReplaceAll";
})(ReplaceMode || (ReplaceMode = {}));
function getTextLength(text, pen) {
  var textScale = pen.calculative.worldRect.height * 14 / 16;
  var chinese = text.match(/[\u4e00-\u9fa5]/g) || "";
  var chineseLen = chinese.length;
  var width = (text.length - chineseLen) * textScale * 0.6 + chineseLen * textScale;
  return width;
}
function initOptions(pen) {
  if (pen.direction == "horizontal") {
    var optionPos_1 = [];
    var textLength_1 = 0;
    var h_1 = pen.height;
    pen.checkboxHeight = h_1;
    pen.options.forEach(function(item, index) {
      optionPos_1.push(index * (40 + h_1) + textLength_1);
      textLength_1 += getTextLength(item.text, pen);
    });
    pen.optionPos = optionPos_1;
    var width = optionPos_1.length * (40 + h_1) + textLength_1;
    pen.checkboxWidth = width;
    pen.width = width;
    pen.calculative.width = width;
    pen.calculative.worldRect = {
      x: pen.x,
      y: pen.y,
      height: pen.height,
      width: pen.width,
      center: {
        x: pen.x + pen.width / 2,
        y: pen.y + pen.height / 2
      }
    };
    calcRightBottom(pen.calculative.worldRect);
  } else if (pen.direction == "vertical") {
    if (pen.optionInterval == void 0) {
      pen.optionInterval = 20;
    }
    if (!pen.optionHeight) {
      pen.optionHeight = 20;
    }
    var optionPos_2 = [];
    pen.options.forEach(function(item, index) {
      optionPos_2.push(index * (pen.optionInterval + pen.optionHeight));
    });
    pen.optionPos = optionPos_2;
    var height = optionPos_2[optionPos_2.length - 1] + pen.optionHeight;
    pen.checkboxHeight = height;
    if (!pen.width) {
      pen.height = height;
      pen.calculative.height = height;
      pen.calculative.worldRect = {
        x: pen.x,
        y: pen.y,
        height: pen.height,
        width: pen.width,
        center: {
          x: pen.x + pen.width / 2,
          y: pen.y + pen.height / 2
        }
      };
      calcRightBottom(pen.calculative.worldRect);
    }
  }
}

// node_modules/@meta2d/form-diagram/src/table2.js
var __values2 = function(o) {
  var s = typeof Symbol === "function" && Symbol.iterator, m = s && o[s], i = 0;
  if (m) return m.call(o);
  if (o && typeof o.length === "number") return {
    next: function() {
      if (o && i >= o.length) o = void 0;
      return { value: o && o[i++], done: !o };
    }
  };
  throw new TypeError(s ? "Object is not iterable." : "Symbol.iterator is not defined.");
};
function table2(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = onAdd2;
    if (!pen.rowPos || !pen.colPos || !pen.calculative.maxOffsetY) {
      pen.onAdd(pen);
    }
    pen.onMouseMove = onMouseMove2;
    pen.onMouseLeave = onMouseLeave2;
    pen.onMouseDown = onMouseDown2;
    pen.onShowInput = onShowInput2;
    pen.onInput = onInput2;
    pen.onValue = onValue2;
    pen.onBeforeValue = beforeValue2;
    pen.onMouseEnter = onMouseEnter;
    pen.onWheel = onWheel;
    pen.onDestroy = onDestroy;
  }
  if (pen.data.length !== pen.rowPos.length) {
    pen.initWorldRect = null;
    pen.calculative.isUpdateData = true;
    pen.onValue(pen);
  }
  if (pen.data[0].length !== pen.colPos.length) {
    pen.initWorldRect = null;
    pen.calculative.isUpdateData = true;
    pen.onValue(pen);
  }
  var data = pen.calculative.canvas.store.data;
  var options = pen.calculative.canvas.store.options;
  pen.color = pen.color || data.color || options.color;
  pen.textColor = pen.textColor || pen.color || data.textColor || options.textColor;
  pen.activeColor = pen.activeColor || options.activeColor;
  pen.hoverColor = pen.hoverColor || options.hoverColor;
  pen.activeBackground = pen.activeBackground || options.activeBackground;
  pen.hoverBackground = pen.hoverBackground || options.hoverBackground;
  if (!pen.hasHeader) {
    ctx.save();
    ctx.beginPath();
    var _a = pen.calculative.worldRect, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
    ctx.fillStyle = "#fff0";
    ctx.rect(x - 1, y - 1, width + 2, height + 2);
    ctx.fill();
    ctx.clip();
  }
  drawGridLine2(ctx, pen);
  drawCell2(ctx, pen);
  drawNote(ctx, pen);
  ctx.restore();
  pen.isFirstTime = false;
}
function drawNote(ctx, pen) {
  if (!pen.calculative.hover) {
    return;
  }
  if (!pen.calculative.hoverCell) {
    return;
  }
  if (pen.calculative.isInput) {
    return;
  }
  if (!pen.calculative.isHover) {
    return;
  }
  var rect = pen.calculative.worldRect;
  var mousePos = pen.calculative.canvas.mousePos;
  if (!(mousePos.x > rect.x && mousePos.x < rect.x + rect.width && mousePos.y > rect.y && mousePos.y < rect.y + rect.height)) {
    pen.calculative.hover = false;
    pen.calculative.isHover = false;
    pen.calculative.hoverCell = void 0;
    return;
  }
  var _a = pen.calculative.hoverCell, row = _a.row, col = _a.col;
  var _b = pen.calculative.canvas.mousePos, x = _b.x, y = _b.y;
  if (!pen.data[row]) {
    return;
  }
  var text = pen.data[row][col];
  if (typeof text === "object" || !text) {
    return;
  }
  ctx.save();
  ctx.beginPath();
  ctx.textAlign = "start";
  ctx.textBaseline = "middle";
  ctx.font = ctx.font = (pen.calculative.fontStyle || "") + " normal " + (pen.calculative.fontWeight || "") + " " + (pen.calculative.fontSize || 12) + "px " + pen.calculative.fontFamily;
  var noteWidth = ctx.measureText(text).width;
  ctx.beginPath();
  ctx.fillStyle = "#fff";
  ctx.strokeStyle = "#000";
  ctx.moveTo(x, y);
  ctx.rect(x - 10, y, noteWidth + 20, 20);
  ctx.fill();
  ctx.stroke();
  ctx.beginPath();
  ctx.fillStyle = "#000";
  ctx.fillText(text, x, y + 10);
  ctx.restore();
}
function initRect2(pen) {
  var colPos = [];
  var rowPos = [];
  var colStyle = {};
  if (!pen.rowHeight) {
    pen.rowHeight = 40;
  }
  if (!pen.colWidth) {
    pen.colWidth = 150;
  }
  var width = 0;
  var _col = pen.styles && pen.styles.filter(function(item) {
    return item.col !== void 0 && item.row === void 0 && item.width;
  });
  var _colWidthMap = {};
  _col && _col.forEach(function(_c) {
    _colWidthMap[_c.col] = _c.width;
  });
  var _loop_1 = function(i2) {
    width += (_colWidthMap[i2] || pen.colWidth) * pen.calculative.canvas.store.data.scale;
    colPos.push(width);
    var style = pen.styles && pen.styles.filter(function(item) {
      return item.col === i2 && item.row === void 0;
    });
    if (style) {
      colStyle[i2] = style[0];
    }
  };
  for (var i = 0; i < pen.data[0].length; i++) {
    _loop_1(i);
  }
  var height = 0;
  var _row = pen.styles && pen.styles.filter(function(item) {
    return item.col === void 0 && item.row !== void 0 && item.height;
  });
  var _rowHeightMap = {};
  _row && _row.forEach(function(_r) {
    _rowHeightMap[_r.row] = _r.height;
  });
  var finalHight = height;
  for (var j = 0; j < pen.data.length; j++) {
    height += (_rowHeightMap[j] || pen.rowHeight) * pen.calculative.canvas.store.data.scale;
    rowPos.push(height);
    if (j < pen.maxNum) {
      finalHight = height;
    }
  }
  pen.calculative.maxOffsetY = (height - finalHight) / pen.calculative.canvas.store.data.scale;
  if (pen.initWorldRect) {
    return;
  }
  pen.colPos = colPos;
  pen.rowPos = rowPos;
  pen.colStyle = colStyle;
  pen.initScale = pen.calculative.canvas.store.data.scale;
  pen.tableWidth = width;
  pen.tableHeight = finalHight || height;
  pen.calculative.width = width;
  pen.calculative.height = finalHight || height;
  pen.calculative.width = width;
  pen.calculative.height = finalHight || height;
  if (!pen.height) {
    pen.height = pen.calculative.height;
  }
  if (!pen.width) {
    pen.width = pen.calculative.width;
  }
  var x = pen.x;
  var y = pen.y;
  if (pen.parentId) {
    var parentPen = pen.calculative.canvas.store.pens[pen.parentId];
    x = parentPen.calculative.worldRect.x + parentPen.calculative.worldRect.width * pen.x;
    y = parentPen.calculative.worldRect.y + parentPen.calculative.worldRect.height * pen.y;
  }
  pen.calculative.worldRect = {
    x,
    y,
    height: pen.calculative.height,
    width: pen.calculative.width,
    center: {
      x: pen.x + pen.calculative.width / 2,
      y: pen.y + pen.calculative.height / 2
    }
  };
  pen.width = pen.calculative.width;
  pen.height = pen.calculative.height;
  if (!pen.initWorldRect) {
    pen.initWorldRect = {
      width: pen.calculative.worldRect.width,
      height: pen.calculative.worldRect.height
    };
  }
  calcRightBottom(pen.calculative.worldRect);
}
function drawGridLine2(ctx, pen) {
  var e_1, _a;
  if (!pen.colPos) {
    return;
  }
  var _b = pen.calculative.worldRect, x = _b.x, y = _b.y, width = _b.width, height = _b.height, ex = _b.ex, ey = _b.ey;
  ctx.save();
  ctx.beginPath();
  ctx.strokeStyle = pen.color;
  var wr = pen.calculative.borderRadius || 0, hr = wr;
  if (wr < 1) {
    wr = width * wr;
    hr = height * hr;
  }
  var r = wr < hr ? wr : hr;
  if (width < 2 * r) {
    r = width / 2;
  }
  if (height < 2 * r) {
    r = height / 2;
  }
  ctx.moveTo(x + r, y);
  ctx.arcTo(ex, y, ex, ey, r);
  ctx.arcTo(ex, ey, x, ey, r);
  ctx.arcTo(x, ey, x, y, r);
  ctx.arcTo(x, y, ex, y, r);
  if (pen.background) {
    ctx.fillStyle = pen.background;
    ctx.fill();
  }
  if (pen.bordered !== false) {
    ctx.strokeStyle = pen.borderColor || "#424B61";
    ctx.stroke();
  }
  if (pen.hLine !== false) {
    var last = pen.rowPos[pen.rowPos.length - 1];
    if (pen.hasHeader) {
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight);
      ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight);
      ctx.strokeStyle = pen.borderColor || "#424B61";
      ctx.stroke();
    }
    try {
      for (var _d = __values2(pen.rowPos), _e = _d.next(); !_e.done; _e = _d.next()) {
        var item = _e.value;
        if (item === last) {
          continue;
        }
        var y_1 = item * pen.calculative.worldRect.height / pen.tableHeight - pen.offsetY * pen.calculative.canvas.store.data.scale;
        if (pen.hasHeader) {
          if (y_1 < 0 + pen.rowPos[0] || y_1 > pen.calculative.worldRect.height) {
            continue;
          }
        } else {
          if (y_1 < 0 || y_1 > pen.calculative.worldRect.height) {
            continue;
          }
        }
        ctx.beginPath();
        ctx.moveTo(pen.calculative.worldRect.x, pen.calculative.worldRect.y + y_1);
        ctx.lineTo(pen.calculative.worldRect.ex, pen.calculative.worldRect.y + y_1);
        ctx.strokeStyle = pen.borderColor || "#424B61";
        ctx.stroke();
      }
    } catch (e_1_1) {
      e_1 = { error: e_1_1 };
    } finally {
      try {
        if (_e && !_e.done && (_a = _d.return)) _a.call(_d);
      } finally {
        if (e_1) throw e_1.error;
      }
    }
  }
  if (pen.vLine !== false) {
    var last_1 = pen.colPos[pen.colPos.length - 1];
    pen.colPos.forEach(function(item2, i) {
      if (item2 === last_1) {
        return;
      }
      var x2 = item2 * pen.calculative.worldRect.width / pen.tableWidth;
      ctx.beginPath();
      ctx.moveTo(pen.calculative.worldRect.x + x2, pen.calculative.worldRect.y);
      ctx.lineTo(pen.calculative.worldRect.x + x2, pen.calculative.worldRect.ey);
      ctx.strokeStyle = pen.borderColor || "#424B61";
      ctx.stroke();
    });
  }
  ctx.restore();
}
function drawCell2(ctx, pen) {
  var _a, _b, _d, _e, _f;
  if (!pen.colPos) {
    return;
  }
  if (!pen.calculative.texts) {
    pen.calculative.texts = [];
  }
  var textScale = 1;
  var _loop_2 = function(i2) {
    if (pen.hasHeader && i2 === 1) {
      ctx.save();
      ctx.beginPath();
      var _g = pen.calculative.worldRect, x = _g.x, y = _g.y, width = _g.width, height = _g.height;
      ctx.fillStyle = "#fff0";
      ctx.rect(x - 1, y + pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight - 1, width + 2, height - pen.rowPos[0] * pen.calculative.worldRect.height / pen.tableHeight + 2);
      ctx.fill();
      ctx.clip();
    }
    var rowStyle = getRow(pen, i2).style;
    var _loop_3 = function(j2) {
      var _h = getCell2(pen, i2, j2), cell = _h.value, cellStyle = _h.style;
      var isSuccess = true;
      if (Array.isArray(cellStyle) && cellStyle.length > 0) {
        var successIdx_1 = 0;
        cellStyle.forEach(function(item, idx) {
          if (item.wheres) {
            var success = item.wheres.every(function(where) {
              var fn = new Function("attr", "return attr " + where.comparison + " " + where.value);
              return fn(cell);
            });
            if (success) {
              successIdx_1 = idx;
            }
          }
        });
        cellStyle = cellStyle[successIdx_1];
      } else {
        if (cellStyle.wheres && Array.isArray(cellStyle.wheres)) {
          isSuccess = false;
          isSuccess = cellStyle.wheres.every(function(where) {
            var fn = new Function("attr", "return attr " + where.comparison + " " + where.value);
            return fn(cell);
          });
        }
      }
      var color = pen.color;
      var textColor = pen.textColor || pen.color;
      var background = null;
      var fontSize = null;
      var fontWeight = null;
      var fontStyle = null;
      if (isSuccess) {
        color = cellStyle.color || rowStyle.color || pen.color;
        textColor = cellStyle.textColor || rowStyle.textColor || pen.textColor;
        background = cellStyle.background || rowStyle.background;
        fontSize = (cellStyle.fontSize || rowStyle.fontSize || 0) * pen.calculative.canvas.store.data.scale;
        fontWeight = cellStyle.fontWeight || rowStyle.fontWeight;
        fontStyle = cellStyle.fontStyle || rowStyle.fontStyle;
      }
      var activeColor = void 0;
      if (pen.stripe) {
        if (pen.hasHeader !== false) {
          if (i2 % 2 === 1) {
            background = background || pen.stripeColor || "#407FFF1F";
          }
        } else {
          if (i2 % 2 === 0) {
            background = background || pen.stripeColor || "#407FFF1F";
          }
        }
      }
      if (pen.calculative.active && ((_a = pen.calculative.activeCell) === null || _a === void 0 ? void 0 : _a.row) === i2 && ((_b = pen.calculative.activeCell) === null || _b === void 0 ? void 0 : _b.col) === j2) {
        color = pen.activeColor;
        background = pen.activeBackground;
        activeColor = color;
        textColor = pen.activeTextColor || pen.activeColor;
      }
      if (pen.calculative.hover && ((_d = pen.calculative.hoverCell) === null || _d === void 0 ? void 0 : _d.row) === i2 && ((_e = pen.calculative.hoverCell) === null || _e === void 0 ? void 0 : _e.col) === j2) {
        color = pen.hoverColor;
        background = pen.hoverBackground;
        textColor = pen.hoverTextColor || pen.hoverColor;
        activeColor = color;
      }
      var rect = getCellRect2(pen, i2, j2);
      if (rect.y + rect.height < pen.calculative.worldRect.y || rect.y > pen.calculative.worldRect.height + pen.calculative.worldRect.y) {
        return "continue";
      }
      if (background) {
        ctx.save();
        ctx.beginPath();
        ctx.fillStyle = background;
        ctx.fillRect(rect.x, rect.y, rect.width + 0.25 * pen.calculative.canvas.store.data.scale, rect.height);
        ctx.restore();
      }
      if (activeColor) {
        ctx.save();
        ctx.beginPath();
        ctx.strokeStyle = activeColor;
        ctx.strokeRect(rect.x, rect.y, rect.width, rect.height);
        ctx.restore();
      }
      pen.calculative.worldTextRect = rect;
      var rowText = pen.calculative.texts[i2];
      if (!pen.calculative.texts[i2]) {
        rowText = [];
        pen.calculative.texts.push(rowText);
      }
      if (rowText[j2] == null) {
        if (typeof cell === "object") {
          var _colPen = pen.styles && pen.styles.filter(function(item) {
            return item.col === j2 && item.row === void 0 && item.pens;
          });
          if (_colPen.length > 0) {
            rowText[j2] = "";
            if (pen.isFirstTime) {
              if (pen.maxNum) {
                if (pen.hasHeader && i2 >= pen.maxNum) {
                  cell.visible = false;
                }
              }
              var childrenPen = JSON.parse(JSON.stringify(_colPen[0].pens));
              childrenPen.forEach(function(item) {
                Object.assign(item, { row: i2, col: j2 }, cell);
                item.activeBackground = item.background;
                item.hoverBackground = item.background;
                item.activeColor = item.color;
                item.hoverColor = item.color;
                item.activeTextColor = item.textColor;
                item.hoverTextColor = item.textColor;
                item.height *= pen.calculative.canvas.store.data.scale;
                item.width *= pen.calculative.canvas.store.data.scale;
              });
              calcChildrenRect2(pen, rect, childrenPen);
              pen.calculative.canvas.parent.pushChildren(pen, childrenPen);
            }
            return "continue";
          }
        } else if (cell === void 0) {
          rowText[j2] = "";
        } else {
          rowText[j2] = cell.text || cell + "";
        }
        if (!rowText[j2]) {
          return "continue";
        }
        rowText[j2] = calcTextLines(pen, rowText[j2]);
      }
      if (!rowText[j2]) {
        return "continue";
      }
      ctx.save();
      ctx.beginPath();
      ctx.fillStyle = textColor;
      ctx.textAlign = "center";
      ctx.textBaseline = "middle";
      ctx.font = (fontStyle || pen.calculative.fontStyle || "") + " normal " + (fontWeight || pen.calculative.fontWeight || "") + " " + (fontSize || pen.calculative.fontSize || 12) * textScale + "px " + pen.calculative.fontFamily;
      var textAlign = pen.colStyle && ((_f = pen.colStyle[j2]) === null || _f === void 0 ? void 0 : _f.textAlign);
      if (textAlign) {
        ctx.textAlign = textAlign;
      }
      if (rowText[j2].length === 1) {
        if (textAlign === "left") {
          ctx.fillText(rowText[j2][0], rect.x, rect.y + rect.height / 2);
        } else if (textAlign === "right") {
          ctx.fillText(rowText[j2][0], rect.x + rect.width, rect.y + rect.height / 2);
        } else {
          ctx.fillText(rowText[j2][0], rect.x + rect.width / 2, rect.y + rect.height / 2);
        }
      } else {
        var y_2 = 0.55;
        var lineHeight_1 = (fontSize || pen.calculative.fontSize) * pen.calculative.lineHeight * textScale;
        var h = rowText[j2].length * lineHeight_1;
        var top_1 = (rect.height - h) / 2;
        if (textAlign === "left") {
          rowText[j2].forEach(function(text, i3) {
            ctx.fillText(text, rect.x, rect.y + top_1 + (i3 + y_2) * lineHeight_1);
          });
        } else if (textAlign === "right") {
          rowText[j2].forEach(function(text, i3) {
            ctx.fillText(text, rect.x + rect.width, rect.y + top_1 + (i3 + y_2) * lineHeight_1);
          });
        } else {
          rowText[j2].forEach(function(text, i3) {
            ctx.fillText(text, rect.x + rect.width / 2, rect.y + top_1 + (i3 + y_2) * lineHeight_1);
          });
        }
      }
      ctx.restore();
    };
    for (var j = 0; j < pen.colPos.length; j++) {
      _loop_3(j);
    }
  };
  for (var i = 0; i < pen.rowPos.length; i++) {
    _loop_2(i);
  }
}
function onAdd2(pen) {
  var _a;
  createInterval(pen);
  if (!((_a = pen.children) === null || _a === void 0 ? void 0 : _a.length)) {
    pen.isFirstTime = true;
  }
  if (!pen.offsetY) {
    pen.offsetY = 0;
  }
  initRect2(pen);
}
function onShowInput2(pen, e) {
  if (!pen.calculative.hoverCell) {
    return;
  }
  var cell = getCell2(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col).value;
  if (typeof cell === "object") {
    return;
  }
  pen.calculative.isHover = false;
  pen.calculative.isInput = true;
  pen.calculative.canvas.render();
  pen.calculative.inputCell = pen.calculative.hoverCell;
  var rect = getCellRect2(pen, pen.calculative.hoverCell.row, pen.calculative.hoverCell.col);
  pen.calculative.tempText = cell.text || cell + "";
  pen.calculative.canvas.showInput(pen, rect, "#ffffff");
}
function onInput2(pen, text) {
  if (!pen.calculative.inputCell) {
    return;
  }
  setCellText2(pen, pen.calculative.inputCell.row, pen.calculative.inputCell.col, text);
  pen.calculative.isInput = false;
  pen.calculative.isHover = true;
  pen.calculative.canvas.render();
}
function onMouseMove2(pen, e) {
  if (pen.timer) {
    pen.calculative.isHover = false;
    clearTimeout(pen.timer);
  }
  pen.timer = setTimeout(function() {
    pen.calculative.isHover = true;
    pen.calculative.canvas.render();
  }, 500);
  pen.calculative.hoverCell = getCellIndex2(pen, e);
  pen.calculative.canvas.render();
}
function onMouseLeave2(pen, e) {
  createInterval(pen);
  pen.calculative.hoverCell = void 0;
  pen.calculative.canvas.render();
}
function onMouseDown2(pen, e) {
  pen.calculative.activeCell = getCellIndex2(pen, e);
  pen.calculative.canvas.render();
}
function getCellIndex2(pen, e) {
  var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var pos = { row: 0, col: 0 };
  for (var i = 0; i < pen.colPos.length; i++) {
    if (e.x > pen.calculative.worldRect.x + pen.colPos[i] * scaleX) {
      pos.col = i + 1;
    }
  }
  for (var i = 0; i < pen.rowPos.length; i++) {
    if (e.y > pen.calculative.worldRect.y + pen.rowPos[i] * scaleY - pen.offsetY * pen.calculative.canvas.store.data.scale) {
      pos.row = i + 1;
    }
  }
  return pos;
}
function getCell2(pen, rowIndex, colIndex) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  var row = pen.data[rowIndex];
  var style = pen.styles && pen.styles.filter(function(item) {
    return item.row === rowIndex && item.col === colIndex;
  });
  if (Array.isArray(row)) {
    return { value: row[colIndex], style: (style === null || style === void 0 ? void 0 : style.length) > 0 ? style.length > 1 ? style : style[0] : {} };
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
}
function getRow(pen, rowIndex) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  var row = pen.data[rowIndex];
  var style = pen.styles && pen.styles.filter(function(item) {
    return item.row === rowIndex && !item.col;
  });
  if (Array.isArray(row)) {
    return { value: row, style: (style === null || style === void 0 ? void 0 : style.length) > 0 ? style[0] : {} };
  } else if (!row.data || !Array.isArray(row.data)) {
    return;
  }
}
function setCellText2(pen, rowIndex, colIndex, text) {
  if (!pen.data || !Array.isArray(pen.data)) {
    return;
  }
  pen.isFirstTime = false;
  pen.calculative.texts = void 0;
  var rowData = pen.data[rowIndex];
  if (!rowData) {
    return;
  }
  if (rowData[colIndex] instanceof Object) {
  } else {
    rowData[colIndex] = text;
  }
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
}
function getCellRect2(pen, rowIndex, colIndex) {
  var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var x = 0;
  var ex = pen.colPos[colIndex] * scaleX;
  if (colIndex > 0) {
    x = pen.colPos[colIndex - 1] * scaleX;
  }
  var y = 0;
  var ey = pen.rowPos[rowIndex] * scaleY;
  if (rowIndex > 0) {
    y = pen.rowPos[rowIndex - 1] * scaleY;
  }
  var offset = pen.offsetY * pen.calculative.canvas.store.data.scale;
  if (rowIndex === 0 && pen.hasHeader) {
    offset = 0;
  }
  return {
    x: pen.calculative.worldRect.x + x,
    y: pen.calculative.worldRect.y + y - offset,
    ex: pen.calculative.worldRect.x + ex,
    ey: pen.calculative.worldRect.y + ey - offset,
    width: ex - x,
    height: ey - y
  };
}
function calcChildrenRect2(pen, rect, children) {
  var e_2, _a, e_3, _b;
  var scaleX = pen.calculative.worldRect.width / pen.tableWidth;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var resizeX = 1;
  var resizeY = 1;
  if (pen.initWorldRect) {
    if (pen.calculative.worldRect.width !== pen.initWorldRect.width) {
      resizeX = pen.calculative.worldRect.width / pen.initWorldRect.width;
    }
    if (pen.calculative.worldRect.height !== pen.initWorldRect.height) {
      resizeY = pen.calculative.worldRect.height / pen.initWorldRect.height;
    }
  }
  var height = 0;
  var lastX = 0;
  var lastY = 0;
  var scale = pen.calculative.canvas.store.data.scale;
  if (children.length > 1) {
    try {
      for (var children_1 = __values2(children), children_1_1 = children_1.next(); !children_1_1.done; children_1_1 = children_1.next()) {
        var item = children_1_1.value;
        if (lastX + item.width * scaleX + 20 * scale * scaleX < rect.width) {
          item.x = rect.x + lastX + 10 * scale * scaleX;
          item.y = rect.y + lastY + 10 * scale * scaleY;
          lastX += (item.width + 10 * scale) * scaleX;
          height = Math.max(height, lastY + (item.height + 10 * scale) * scaleY);
        } else {
          lastX = 0;
          lastY = height;
          item.x = rect.x + lastX + 10 * scale * scaleX;
          item.y = rect.y + lastY + 10 * scale * scaleY;
          height += (item.height + 10 * scale) * scaleY;
        }
      }
    } catch (e_2_1) {
      e_2 = { error: e_2_1 };
    } finally {
      try {
        if (children_1_1 && !children_1_1.done && (_a = children_1.return)) _a.call(children_1);
      } finally {
        if (e_2) throw e_2.error;
      }
    }
    if (height + 20 * scale * scaleY < rect.height) {
      var top_2 = (rect.height - height - 10 * scale * scaleY) / 2;
      try {
        for (var children_2 = __values2(children), children_2_1 = children_2.next(); !children_2_1.done; children_2_1 = children_2.next()) {
          var item = children_2_1.value;
          item.y += top_2;
        }
      } catch (e_3_1) {
        e_3 = { error: e_3_1 };
      } finally {
        try {
          if (children_2_1 && !children_2_1.done && (_b = children_2.return)) _b.call(children_2);
        } finally {
          if (e_3) throw e_3.error;
        }
      }
    }
  } else {
    children[0].x = rect.x + (rect.width - children[0].width) / 2;
    children[0].y = rect.y + (rect.height - children[0].height) / 2;
  }
  children.forEach(function(item2) {
    item2.width = item2.width * resizeX / scale;
    item2.height = item2.height * resizeY / scale;
  });
}
function onValue2(pen) {
  if (pen.calculative.isUpdateData) {
    delete pen.calculative.isUpdateData;
    var temChildren = deepClone(pen.children);
    pen.children = [];
    onAdd2(pen);
    temChildren && temChildren.forEach(function(child) {
      pen.calculative.canvas.delForce(pen.calculative.canvas.findOne(child));
    });
    pen.calculative.texts = void 0;
  }
}
function beforeValue2(pen, value) {
  var e_4, _a;
  pen.calculative.isUpdateData = false;
  if (pen.swiper !== void 0) {
    if (pen.swiper) {
      createInterval(pen);
    } else {
      delInterval(pen);
    }
  }
  if (value.styles) {
    pen.initWorldRect = void 0;
  }
  if (value.table || value.col == void 0 && value.row == void 0) {
    if (value.dataY) {
      var replaceMode = pen.replaceMode;
      var data_1 = [];
      if (!replaceMode) {
        data_1 = pen.data.concat(value.dataY);
      } else if (replaceMode === ReplaceMode.Replace) {
        data_1 = pen.data;
        value.dataX && value.dataX.forEach(function(item, index) {
          data_1[item] = value.dataY[index];
        });
      } else if (replaceMode === ReplaceMode.ReplaceAll) {
        if (value.dataX) {
          data_1[0] = value.dataX;
        } else {
          data_1[0] = pen.data[0];
        }
        data_1 = data_1.concat(value.dataY);
      }
      delete value.dataX;
      delete value.dataY;
      pen.calculative.isUpdateData = true;
      return Object.assign(value, { data: data_1 });
    }
    if (value.data || value.styles || value.maxNum) {
      pen.calculative.isUpdateData = true;
    }
    try {
      for (var _b = __values2(Object.keys(value)), _d = _b.next(); !_d.done; _d = _b.next()) {
        var key = _d.value;
        if (key.includes("data.")) {
          pen.calculative.isUpdateData = true;
        }
      }
    } catch (e_4_1) {
      e_4 = { error: e_4_1 };
    } finally {
      try {
        if (_d && !_d.done && (_a = _b.return)) _a.call(_b);
      } finally {
        if (e_4) throw e_4.error;
      }
    }
    return value;
  }
  var rowData = pen.data[value.row];
  if (!rowData) {
    return value;
  }
  if (rowData[value.col] instanceof Object) {
  } else {
    rowData[value.col] = value.value;
  }
  setCellText2(pen, value.row, value.col, value.value);
  pen.calculative.canvas.render();
  delete value.col;
  delete value.row;
  return value;
}
function onWheel(pen, e) {
  if (!pen.locked && !pen.calculative.canvas.store.data.locked) {
    return;
  }
  if (!pen.maxNum) {
    return;
  }
  var offset = 0;
  if (e.deltaY > 0) {
    offset = 4;
  } else {
    offset = -4;
  }
  scroll(pen, offset);
}
function scroll(pen, offset) {
  var _a;
  if (!pen.offsetY) {
    pen.offsetY = 0;
  }
  pen.offsetY += offset;
  if (pen.offsetY > pen.calculative.maxOffsetY) {
    pen.offsetY = pen.calculative.maxOffsetY;
  }
  if (pen.offsetY < 0) {
    pen.offsetY = 0;
  }
  (_a = pen.children) === null || _a === void 0 ? void 0 : _a.forEach(function(item) {
    var _pen = pen.calculative.canvas.store.pens[item];
    changeChildVisible(pen, _pen);
  });
  pen.calculative.canvas.render();
}
function changeChildVisible(pen, _pen) {
  if (!_pen) {
    return;
  }
  if (!_pen.oldY) {
    _pen.oldY = _pen.y;
  }
  var _a = _pen.calculative.worldRect, y = _a.y, height = _a.height;
  var _b = pen.calculative.worldRect, penY = _b.y, penH = _b.height;
  var scale = pen.calculative.canvas.store.data.scale;
  var scaleY = pen.calculative.worldRect.height / pen.tableHeight;
  var rowHeight = pen.rowHeight;
  _pen.y = _pen.oldY - pen.offsetY * scale / pen.calculative.worldRect.height;
  var oldOffset = rowHeight * (pen.initScale || 1) / pen.tableHeight * pen.maxNum;
  pen.calculative.canvas.updatePenRect(_pen);
  if (pen.hasHeader) {
    if (_pen.y < pen.rowPos[0] / pen.tableHeight) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y < pen.rowPos[0] / pen.tableHeight / 2) {
        _pen.oldY += oldOffset;
        var row = _pen.row + pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        var rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else if (_pen.y + _pen.height > 1) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y + _pen.height / 2 > 1) {
        _pen.oldY -= oldOffset;
        var row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        var rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else {
      _pen.visible = true;
      _pen.calculative.visible = true;
    }
  } else {
    if (_pen.y < 0) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y < -rowHeight / pen.tableHeight / 2) {
        _pen.oldY += oldOffset;
        var row = _pen.row + pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        var rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else if (_pen.y + _pen.height > 1) {
      _pen.calculative.visible = false;
      _pen.visible = false;
      if (_pen.y + _pen.height / 2 > 1) {
        _pen.oldY -= oldOffset;
        var row = _pen.row - pen.maxNum;
        if (!pen.data[row]) {
          return;
        }
        var rowStyle = deepClone(pen.data[row][_pen.col]);
        if (rowStyle.background) {
          rowStyle.activeBackground = rowStyle.background;
          rowStyle.hoverBackground = rowStyle.background;
        }
        if (rowStyle.color) {
          rowStyle.hoverColor = rowStyle.color;
          rowStyle.activeColor = rowStyle.color;
        }
        if (rowStyle.textColor) {
          rowStyle.activeTextColor = rowStyle.textColor;
          rowStyle.hoverTextColor = rowStyle.textColor;
        }
        Object.assign(_pen, rowStyle, { row });
        Object.assign(_pen.calculative, rowStyle, { row });
      }
    } else {
      _pen.calculative.visible = true;
      _pen.visible = true;
    }
  }
}
function onDestroy(pen) {
  delInterval(pen);
}
function delInterval(pen) {
  if (pen.interval) {
    globalThis.clearInterval(pen.interval);
    pen.interval = null;
  }
}
function createInterval(pen) {
  if (pen.maxNum && pen.swiper) {
    if (pen.interval) {
      return;
    }
    pen.interval = globalThis.setInterval(function() {
      if (pen.offsetY >= pen.calculative.maxOffsetY) {
        pen.offsetY = 0;
        initChildrenStyle(pen);
      } else {
        if (!(pen.offsetY % pen.rowHeight)) {
          if (!pen.calculative.stap) {
            pen.calculative.stap = 0;
          }
          pen.calculative.stap += 1;
          if (pen.calculative.stap == 12) {
            pen.calculative.stap = 0;
            scroll(pen, 1);
          }
        } else {
          scroll(pen, 1);
        }
      }
    }, 50);
  }
}
function initChildrenStyle(pen) {
  var _a;
  (_a = pen.children) === null || _a === void 0 ? void 0 : _a.forEach(function(item) {
    var rowHeight = pen.rowHeight;
    var _pen = pen.calculative.canvas.store.pens[item];
    if (!_pen) {
      return;
    }
    var oldOffset = rowHeight * (pen.initScale || 1) / pen.tableHeight * pen.maxNum;
    _pen.oldY -= oldOffset;
    var row = _pen.row - pen.maxNum;
    if (!pen.data[row]) {
      return;
    }
    var rowStyle = deepClone(pen.data[row][_pen.col]);
    if (rowStyle.background) {
      rowStyle.activeBackground = rowStyle.background;
      rowStyle.hoverBackground = rowStyle.background;
    }
    if (rowStyle.color) {
      rowStyle.hoverColor = rowStyle.color;
      rowStyle.activeColor = rowStyle.color;
    }
    if (rowStyle.textColor) {
      rowStyle.activeTextColor = rowStyle.textColor;
      rowStyle.hoverTextColor = rowStyle.textColor;
    }
    _pen.calculative.visible = true;
    _pen.visible = true;
    Object.assign(_pen, rowStyle, { row });
    Object.assign(_pen.calculative, rowStyle, { row });
  });
  pen.calculative.canvas.render();
}
function onMouseEnter(pen) {
  delInterval(pen);
}

// node_modules/@meta2d/form-diagram/src/switch.js
function le5leSwitch(ctx, pen) {
  if (!pen.onClick) {
    pen.onClick = click;
  }
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var w = pen.calculative.worldRect.width;
  var h = pen.calculative.worldRect.height;
  if (w < h * 1.5) {
    w = 1.5 * h;
  }
  ctx.beginPath();
  ctx.arc(x + h / 2, y + h / 2, h / 2, Math.PI / 2, Math.PI * 3 / 2);
  ctx.lineTo(x + w - h / 2, y);
  ctx.arc(x + w - h / 2, y + h / 2, h / 2, -Math.PI / 2, Math.PI / 2);
  ctx.lineTo(x + h / 2, y + h);
  if (pen.checked) {
    ctx.fillStyle = pen.onColor;
    if (pen.disabled || pen.disable) {
      ctx.fillStyle = pen.disableOnColor || pSBC(0.6, pen.onColor);
    }
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = "#ffffff";
    ctx.moveTo(x + h * 2, y + h / 2);
    ctx.arc(x + w - h / 2, y + h / 2, h / 2 > 2 ? h / 2 - 2 : 1, 0, Math.PI * 2);
    ctx.fill();
  } else {
    ctx.fillStyle = pen.offColor;
    if (pen.disabled || pen.disable) {
      ctx.fillStyle = pen.disableOffColor || pSBC(0.6, pen.offColor);
    }
    ctx.fill();
    ctx.closePath();
    ctx.beginPath();
    ctx.fillStyle = "#ffffff";
    ctx.moveTo(x + h, y + h / 2);
    ctx.arc(x + h / 2, y + h / 2, h / 2 > 2 ? h / 2 - 2 : 1, 0, Math.PI * 2);
    ctx.fill();
  }
  ctx.closePath();
}
function click(pen) {
  if (pen.disabled || pen.disable) {
    return;
  }
  pen.checked = !pen.checked;
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
  pen.calculative.canvas.render();
}

// node_modules/@meta2d/form-diagram/src/slider.js
function slider(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = initRect3;
    pen.onResize = initRect3;
    pen.onMove = initRect3;
    pen.onMouseMove = mouseMove;
    pen.onMouseDown = mouseDown;
    pen.onValue = onValue3;
    pen.onBeforeValue = beforeValue3;
  }
  if (!pen.calculative.barRect) {
    initRect3(pen);
  }
  var data = pen.calculative.canvas.store.data;
  var options = pen.calculative.canvas.store.options;
  var background = pen.background;
  if (pen.disabled) {
    background = pen.disabledBackground || pSBC(0.6, background);
  }
  ctx.fillStyle = background;
  ctx.beginPath();
  var x = pen.calculative.worldRect.x + pen.calculative.barRect.x;
  var y = pen.calculative.worldRect.y + pen.calculative.barRect.y;
  var w = pen.calculative.barRect.width;
  var h = pen.calculative.barRect.height;
  var r = h / 2;
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, pen.x, pen.y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.fill();
  var activeColor = pen.activeColor || options.activeColor;
  if (pen.disabled) {
    activeColor = pen.disabledColor || pSBC(0.6, activeColor);
  }
  ctx.fillStyle = activeColor;
  ctx.beginPath();
  w = pen.calculative.ballRect.x;
  ctx.moveTo(x + r, y);
  ctx.arcTo(x + w, y, x + w, y + h, r);
  ctx.arcTo(x + w, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, pen.x, pen.y, r);
  ctx.arcTo(x, y, x + w, y, r);
  ctx.fill();
  ctx.fillStyle = pen.btnBackground || "#fff";
  ctx.strokeStyle = activeColor;
  ctx.lineWidth = 2;
  ctx.beginPath();
  x = pen.calculative.worldRect.x + pen.calculative.ballRect.x;
  y = pen.calculative.worldRect.y + pen.calculative.ballRect.y + pen.calculative.ballRect.height / 2;
  ctx.lineWidth = pen.calculative.ballRect.width / 10;
  ctx.arc(x, y, pen.calculative.ballRect.width / 2, 0, Math.PI * 2);
  ctx.fill();
  ctx.stroke();
}
function initRect3(pen) {
  if (!pen._textWidth) {
    pen._textWidth = pen.textWidth || 50;
    pen._fontSize = pen.fontSize || 12;
  }
  pen.textWidth = pen.calculative.worldRect.width;
  pen.calculative.textWidth = pen.textWidth;
  if (!pen.unit) {
    pen.unit = "%";
  }
  if (!pen.sliderWidth) {
    pen.sliderWidth = pen.width;
  }
  if (!pen.sliderHeight) {
    pen.sliderHeight = pen.height;
  }
  if (!pen.calculative.worldRect) {
    return;
  }
  var scaleX = pen.calculative.worldRect.width / pen.sliderWidth;
  var scaleY = pen.calculative.worldRect.height / pen.sliderHeight;
  var textScale = Math.min(scaleX, scaleY);
  pen.fontSize = pen._fontSize * textScale;
  var barWidth = pen.calculative.worldRect.width - pen._textWidth * textScale;
  pen.textLeft = barWidth + 10 * textScale;
  pen.calculative.textLeft = pen.textLeft;
  pen.calculative.barRect = {
    x: 0,
    y: (pen.calculative.worldRect.height - pen.barHeight * scaleY) / 2,
    width: barWidth,
    height: pen.barHeight * scaleY
  };
  calcRightBottom(pen.calculative.barRect);
  calcBallRect(pen);
}
function calcBallRect(pen) {
  var height = pen.calculative.barRect.height * 3.5;
  var progress = pen.calculative.barRect.width * pen.value / 100;
  pen.calculative.ballRect = {
    x: progress,
    y: (pen.calculative.worldRect.height - height) / 2,
    width: height,
    height
  };
  calcRightBottom(pen.calculative.ballRect);
  pen.calculative.text = pen.value + pen.unit;
  calcTextRect(pen);
}
function mouseDown(pen, e) {
  if (pen.disabled) {
    return;
  }
  var pos = e.x - pen.calculative.worldRect.x;
  if (pos > pen.calculative.barRect.width) {
    return;
  }
  var value = Math.round(pos / pen.calculative.barRect.width * 100);
  if (value < pen.min || value > pen.max) {
    return;
  }
  if (value < 0 || value > 100) {
    return;
  }
  pen.value = value;
  calcBallRect(pen);
  pen.calculative.text = pen.value + pen.unit;
  calcTextRect(pen);
  pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
  pen.calculative.canvas.render();
}
function mouseMove(pen, e) {
  if (pen.calculative.canvas.mouseDown) {
    mouseDown(pen, e);
  }
}
function onValue3(pen) {
  if (pen.calculative.isUpdateData) {
    delete pen.calculative.isUpdateData;
    initRect3(pen);
  }
  calcBallRect(pen);
}
function beforeValue3(pen, value) {
  pen.calculative.isUpdateData = false;
  if (value.textWidth || value.barHeight) {
    if (value.textWidth) {
      pen._textWidth = 0;
    }
    pen.calculative.isUpdateData = true;
  }
  return value;
}

// node_modules/@meta2d/form-diagram/src/checkbox.js
function checkbox(ctx, pen) {
  if (!pen.onMouseDown) {
    pen.onMouseDown = onMousedown;
  }
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var h = pen.calculative.worldRect.height;
  var w = pen.calculative.worldRect.width;
  var _a = pen.calculative, fontStyle = _a.fontStyle, fontWeight = _a.fontWeight, fontSize = _a.fontSize, fontFamily = _a.fontFamily, lineHeight = _a.lineHeight;
  var r = 2;
  ctx.beginPath();
  ctx.moveTo(x, y);
  ctx.arcTo(x + h, y, x + h, y + h, r);
  ctx.arcTo(x + h, y + h, x, y + h, r);
  ctx.arcTo(x, y + h, x, y, r);
  ctx.arcTo(x, y, x + h, y, r);
  ctx.strokeStyle = "#d9d9d9";
  ctx.fillStyle = "#ffffff00";
  if (pen.checked) {
    ctx.fillStyle = pen.background || "#1890ff";
    ctx.strokeStyle = pen.background || "#1890ff";
  }
  if (pen.isForbidden || pen.disabled) {
    ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
    ctx.strokeStyle = pen.disabledColor || pSBC(0.6, pen.color) || "#d9d9d9";
  }
  ctx.closePath();
  ctx.fill();
  ctx.stroke();
  ctx.save();
  if (pen.checked) {
    ctx.beginPath();
    ctx.lineWidth = h / 10;
    ctx.strokeStyle = "#ffffff";
    ctx.moveTo(x + 102 / 506 * h, y + h / 2);
    ctx.lineTo(x + 220 / 506 * h, y + 346 / 460 * h);
    ctx.lineTo(x + 404 / 506 * h, y + 142 / 460 * h);
    ctx.stroke();
  }
  ctx.restore();
  ctx.save();
  ctx.fillStyle = pen.disabled || pen.isForbidden ? pen.disabledTextColor || pSBC(0.6, pen.textColor || pen.color) || "#00000040" : getTextColor(pen, pen.calculative.canvas.parent.store) || "#000000d9";
  ctx.textAlign = "start";
  ctx.textBaseline = "middle";
  ctx.font = getFont({
    fontStyle,
    fontWeight,
    fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
    fontSize,
    lineHeight
  });
  ctx.fillText(pen.value + "", x + h + 10, y + h / 2);
  ctx.restore();
}
function onMousedown(pen, e) {
  if (!pen.isForbidden) {
    pen.checked = !pen.checked;
    pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
    pen.calculative.canvas.render();
  }
}

// node_modules/@meta2d/form-diagram/src/radio.js
function radio(ctx, pen) {
  if (!pen.onAdd) {
    pen.onAdd = onAdd3;
    if (!pen.optionPos) {
      pen.onAdd(pen);
      pen.calculative.canvas.parent.active([pen]);
    }
    pen.onMouseDown = onMousedown2;
    pen.onValue = onValue4;
  }
  var x = pen.calculative.worldRect.x;
  var y = pen.calculative.worldRect.y;
  var h = pen.calculative.worldRect.height;
  var w = pen.calculative.worldRect.width;
  if (!pen.optionPos) {
    return;
  }
  var _a = pen.calculative, fontStyle = _a.fontStyle, fontWeight = _a.fontWeight, fontSize = _a.fontSize, fontFamily = _a.fontFamily, lineHeight = _a.lineHeight;
  if (pen.direction == "horizontal") {
    for (var i = 0; i < pen.optionPos.length; i++) {
      var gap = pen.optionPos[i] * w / pen.checkboxWidth;
      var isForbidden = pen.options[i].isForbidden || pen.disabled;
      ctx.beginPath();
      ctx.arc(x + gap + h / 2, y + h / 2, h / 2, 0, Math.PI * 2);
      ctx.strokeStyle = "#d9d9d9";
      ctx.fillStyle = "#ffffff00";
      if (pen.options[i].text === pen.checked) {
        ctx.strokeStyle = pen.options[i].background || pen.background || "#1890ff";
      }
      if (isForbidden) {
        ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
        ctx.strokeStyle = pen.disabledColor || pSBC(0.6, pen.color) || "#d9d9d9";
        if (pen.options[i].text === pen.checked) {
          ctx.fillStyle = "#ffffff00";
        }
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.save();
      if (pen.options[i].text === pen.checked) {
        ctx.beginPath();
        ctx.strokeStyle = pen.options[i].background ? pen.options[i].background + "20" : pen.background || "#1890ff20";
        if (isForbidden) {
          ctx.strokeStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
        }
        ctx.arc(x + h / 2 + gap, y + h / 2, h / 2 + 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = pen.options[i].background || pen.background || "#1890ff";
        if (isForbidden) {
          ctx.fillStyle = pen.disabledBackground || pSBC(0.6, pen.background) || "#ebebeb";
        }
        ctx.arc(x + h / 2 + gap, y + h / 2, h / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.restore();
      ctx.save();
      ctx.fillStyle = isForbidden ? pen.disabledTextColor || "#00000040" : getTextColor(pen, pen.calculative.canvas.parent.store) || "#000000d9";
      var textScale = pen.calculative.worldRect.height * 14 / 16;
      ctx.textAlign = "start";
      ctx.textBaseline = "middle";
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
        fontSize: textScale,
        lineHeight
      });
      ctx.fillText(pen.options[i].text, x + h + gap + 10 / pen.checkboxWidth * w, y + h / 2);
      ctx.restore();
    }
  } else if (pen.direction == "vertical") {
    var optionHeight = pen.optionHeight * h / pen.checkboxHeight;
    for (var i = 0; i < pen.optionPos.length; i++) {
      var gap = pen.optionPos[i] * h / pen.checkboxHeight;
      var isForbidden = pen.options[i].isForbidden;
      ctx.beginPath();
      ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 2, 0, Math.PI * 2);
      ctx.strokeStyle = "#d9d9d9";
      ctx.fillStyle = "#ffffff00";
      if (pen.options[i].text === pen.checked) {
        ctx.strokeStyle = pen.options[i].background || "#1890ff";
      }
      if (isForbidden) {
        ctx.fillStyle = "#ebebeb";
        ctx.strokeStyle = "#d9d9d9";
      }
      ctx.closePath();
      ctx.fill();
      ctx.stroke();
      ctx.save();
      if (!isForbidden && pen.options[i].text === pen.checked) {
        ctx.beginPath();
        ctx.strokeStyle = pen.options[i].background ? pen.options[i].background + "20" : "#1890ff20";
        ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 2 + 1.5, 0, Math.PI * 2);
        ctx.stroke();
        ctx.closePath();
        ctx.beginPath();
        ctx.fillStyle = pen.options[i].background || "#1890ff";
        ctx.arc(x + optionHeight / 2, y + optionHeight / 2 + gap, optionHeight / 4, 0, Math.PI * 2);
        ctx.fill();
        ctx.closePath();
      }
      ctx.restore();
      ctx.save();
      ctx.fillStyle = isForbidden ? "#00000040" : getTextColor(pen, pen.calculative.canvas.parent.store) || "#000000d9";
      var textScale = 14 * pen.calculative.worldRect.height / pen.checkboxHeight;
      ctx.textAlign = "start";
      ctx.textBaseline = "middle";
      ctx.font = getFont({
        fontStyle,
        fontWeight,
        fontFamily: fontFamily || pen.calculative.canvas.parent.store.options.fontFamily,
        fontSize: textScale,
        lineHeight
      });
      ctx.fillText(pen.options[i].text, x + optionHeight + 10, y + optionHeight / 2 + gap);
      ctx.restore();
    }
  }
}
function onAdd3(pen) {
  initOptions(pen);
}
function onMousedown2(pen, e) {
  if (pen.direction == "horizontal") {
    for (var i = 0; i < pen.optionPos.length; i++) {
      if (!pen.options[i].isForbidden && e.x > pen.calculative.worldRect.x + pen.optionPos[i] * pen.calculative.worldRect.width / pen.checkboxWidth && e.x < pen.calculative.worldRect.x + (pen.optionPos[i] + pen.height) / pen.checkboxWidth * pen.calculative.worldRect.width + getTextLength(pen.options[i].text, pen) + 10 / pen.checkboxWidth * pen.calculative.worldRect.width) {
        pen.checked = pen.options[i].text;
        pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
      }
    }
  } else if (pen.direction == "vertical") {
    var scaleY = pen.calculative.worldRect.height / pen.checkboxHeight;
    for (var i = 0; i < pen.optionPos.length; i++) {
      if (!pen.options[i].isForbidden && e.y > pen.calculative.worldRect.y + pen.optionPos[i] * scaleY && e.y < pen.calculative.worldRect.y + (pen.optionPos[i] + pen.optionHeight) * scaleY) {
        pen.checked = pen.options[i].text;
        pen.calculative.canvas.store.emitter.emit("valueUpdate", pen);
      }
    }
  }
  pen.calculative.canvas.render();
}
function onValue4(pen) {
  initOptions(pen);
}

// node_modules/@meta2d/form-diagram/src/time.js
function time(pen, ctx) {
  var path = !ctx ? new Path2D() : ctx;
  var _a = pen.calculative.worldRect, x = _a.x, y = _a.y, width = _a.width, height = _a.height;
  path.rect(x, y, width, height);
  if (!pen.onAdd) {
    pen.onAdd = onAdd4;
    pen.onDestroy = onDestroy2;
    if (pen.interval) {
      pen.onDestroy(pen);
      pen.onAdd(pen);
    }
  }
  if (!pen.interval) {
    pen.onAdd(pen);
  }
  if (path instanceof Path2D)
    return path;
  return;
}
function formatTime(pen) {
  var weeks = ["", "", "", "", "", "", ""];
  var now = /* @__PURE__ */ new Date();
  var year = now.getFullYear();
  var pad = "";
  if (pen.fillZero) {
    pad = "0";
  }
  var month = (now.getMonth() + 1 + "").padStart(2, pad);
  var day = (now.getDate() + "").padStart(2, pad);
  var week = now.getDay();
  var hours = (now.getHours() + "").padStart(2, pad);
  var minutes = (now.getMinutes() + "").padStart(2, pad);
  var seconds = (now.getSeconds() + "").padStart(2, pad);
  var fn = new Function("year", "month", "day", "week", "hours", "minutes", "seconds", pen.timeFormat ? "return " + pen.timeFormat : "return `${year}:${month}:${day} ${hours}:${minutes}:${seconds} ${week}`");
  var time2 = fn(year, month, day, weeks[week], hours, minutes, seconds);
  return time2;
}
function onAdd4(pen) {
  pen.interval = setInterval(function() {
    var text = formatTime(pen);
    pen.calculative.canvas.parent.setValue({ id: pen.id, text }, { history: false, doEvent: false, render: false });
    pen.calculative.canvas.render();
  }, pen.timeout || 1e3);
}
function onDestroy2(pen) {
  if (pen.interval) {
    clearInterval(pen.interval);
    pen.interval = void 0;
  }
}

// node_modules/@meta2d/form-diagram/src/register.js
function formPens() {
  return {
    radio,
    switch: le5leSwitch,
    slider,
    checkbox,
    table: table2,
    table2
  };
}
function formPath2DPens() {
  return {
    time
  };
}
export {
  checkbox,
  formPath2DPens,
  formPens,
  le5leSwitch,
  slider,
  table,
  table2,
  time
};
//# sourceMappingURL=@meta2d_form-diagram.js.map
